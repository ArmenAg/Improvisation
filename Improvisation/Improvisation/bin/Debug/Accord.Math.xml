<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Accord.Math</name>
    </assembly>
    <members>
        <member name="T:Accord.Math.MatrixFormatter">
            <summary>
              Defines how matrices are formatted and displayed, depending on the
              chosen format representation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatter.Format(System.String,System.Object,System.IFormatProvider)">
            <summary>
              Converts the value of a specified object to an equivalent string
              representation using specified formatting information.
            </summary>
            <param name="format">A format string containing formatting specifications.</param>
            <param name="arg">An object to format.</param>
            <param name="formatProvider">
              An <see cref="T:System.IFormatProvider"/> object that supplies
              format information about the current instance.</param>
            <returns>
              The string representation of the value of <paramref name="arg"/>,
              formatted as specified by <paramref name="format"/> and
              <paramref name="formatProvider"/>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatter.Format(System.String,System.Array,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Converts a jagged or multidimensional array into a <a cref="T:System.String">System.String</a> representation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatter.parseOptions(System.String,System.String@,System.String@)">
            <summary>
              Parses a format string containing the format options for the matrix representation.
            </summary>
        </member>
        <member name="M:Accord.Math.MatrixFormatter.handleOtherFormats(System.String,System.Object,System.IFormatProvider)">
            <summary>
              Handles formatting for objects other than matrices.
            </summary>
        </member>
        <member name="M:Accord.Math.MatrixFormatter.ParseJagged(System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Converts a matrix represented in a System.String into a jagged array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatter.ParseMultidimensional(System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Converts a matrix represented in a System.String into a multi-dimensional array.
            </summary>
            
        </member>
        <member name="T:Accord.Math.DefaultMatrixFormatProvider">
            <summary>
              Gets the default matrix representation, where each row
              is separated by a new line, and columns are separated by spaces.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              matrices and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from a multidimensional matrix to a 
              string representation:</para>
              
            <code>
              // Declare a number array
              double[,] x = 
              {
                 { 1, 2, 3, 4 },
                 { 5, 6, 7, 8 },
              };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(DefaultMatrixFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              @"1, 2, 3, 4
                5, 6, 7, 8";
            </code>
            
            <para>
              Converting from strings to actual matrices:</para>
            
            <code>
              // Declare an input string
              string str = @"1, 2, 3, 4
                            "5, 6, 7, 8";
              
              // Convert the string representation to an actual number array:
              double[,] matrix = Matrix.Parse(str, DefaultMatrixFormatProvider.InvariantCulture);
              
              // matrix will now contain the actual multidimensional 
              // matrix representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="T:Accord.Math.MatrixFormatProviderBase">
            <summary>
              Base class for IMatrixFormatProvider implementers.
            </summary>
            
        </member>
        <member name="T:Accord.Math.IMatrixFormatProvider">
            <summary>
              Common interface for Matrix format providers.
            </summary>
            
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatMatrixStart">
            <summary>A string denoting the start of the matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatMatrixEnd">
            <summary>A string denoting the end of the matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatRowStart">
            <summary>A string denoting the start of a matrix row to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatRowEnd">
            <summary>A string denoting the end of a matrix row to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatColStart">
            <summary>A string denoting the start of a matrix column to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatColEnd">
            <summary>A string denoting the end of a matrix column to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatRowDelimiter">
            <summary>A string containing the row delimiter for a matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.FormatColDelimiter">
            <summary>A string containing the column delimiter for a matrix to be used in formatting.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseMatrixStart">
            <summary>A string denoting the start of the matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseMatrixEnd">
            <summary>A string denoting the end of the matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseRowStart">
            <summary>A string denoting the start of a matrix row to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseRowEnd">
            <summary>A string denoting the end of a matrix row to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseColStart">
            <summary>A string denoting the start of a matrix column to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseColEnd">
            <summary>A string denoting the end of a matrix column to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseRowDelimiter">
            <summary>A string containing the row delimiter for a matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.ParseColDelimiter">
            <summary>A string containing the column delimiter for a matrix to be used in parsing.</summary>
        </member>
        <member name="P:Accord.Math.IMatrixFormatProvider.InnerProvider">
            <summary>
              Gets the culture specific formatting information
              to be used during parsing or formatting.
            </summary>
        </member>
        <member name="M:Accord.Math.MatrixFormatProviderBase.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.MatrixFormatProviderBase"/> class.
            </summary>
            
            <param name="innerProvider">The inner format provider.</param>
            
        </member>
        <member name="M:Accord.Math.MatrixFormatProviderBase.GetFormat(System.Type)">
            <summary>
              Returns an object that provides formatting services for the specified
              type. Currently, only <see cref="T:Accord.Math.IMatrixFormatProvider"/> is supported.
            </summary>
            <param name="formatType">
              An object that specifies the type of format
              object to return. </param>
            <returns>
              An instance of the object specified by formatType, if the
              <see cref="T:System.IFormatProvider">IFormatProvider</see> implementation
              can supply that type of object; otherwise, null.</returns>
              
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatMatrixStart">
            <summary>
            A string denoting the start of the matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatMatrixEnd">
            <summary>
            A string denoting the end of the matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatRowStart">
            <summary>
            A string denoting the start of a matrix row to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatRowEnd">
            <summary>
            A string denoting the end of a matrix row to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatColStart">
            <summary>
            A string denoting the start of a matrix column to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatColEnd">
            <summary>
            A string denoting the end of a matrix column to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatRowDelimiter">
            <summary>
            A string containing the row delimiter for a matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.FormatColDelimiter">
            <summary>
            A string containing the column delimiter for a matrix to be used in formatting.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseMatrixStart">
            <summary>
            A string denoting the start of the matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseMatrixEnd">
            <summary>
            A string denoting the end of the matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseRowStart">
            <summary>
            A string denoting the start of a matrix row to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseRowEnd">
            <summary>
            A string denoting the end of a matrix row to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseColStart">
            <summary>
            A string denoting the start of a matrix column to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseColEnd">
            <summary>
            A string denoting the end of a matrix column to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseRowDelimiter">
            <summary>
            A string containing the row delimiter for a matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.ParseColDelimiter">
            <summary>
            A string containing the column delimiter for a matrix to be used in parsing.
            </summary>
        </member>
        <member name="P:Accord.Math.MatrixFormatProviderBase.InnerProvider">
            <summary>
              Gets the culture specific formatting information
              to be used during parsing or formatting.
            </summary>
            
        </member>
        <member name="M:Accord.Math.DefaultMatrixFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.DefaultMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.DefaultMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedCholeskyDecompositionF">
            <summary>
                   Cholesky Decomposition of a symmetric, positive definite matrix.
               </summary>
            <remarks>
              <para>
                   For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                   lower triangular matrix <c>L</c> so that <c>A = L * L'</c>. The presented algorithm
                   only checks the upper triangular part of the matrix given as parameter and assumes
                   it is symmetric. If the matrix is not positive definite, the constructor returns a 
                   partial decomposition and sets two internal variables that can be queried using the
                   <see cref="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="T:Accord.Math.Decompositions.ISolverArrayDecomposition`1">
            <summary>
              Common interface for matrix decompositions which
              can be used to solve linear systems of equations
              involving jagged array matrices.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverArrayDecomposition`1.Solve(`0[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverArrayDecomposition`1.Solve(`0[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverArrayDecomposition`1.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new Cholesky Decomposition.
            </summary>
            
            <param name="value">
              The symmetric matrix, given in upper triangular form, to be decomposed.</param>
            <param name="robust">
              True to perform a square-root free LDLt decomposition, false otherwise.</param>
            <param name="inPlace">
              True to perform the decomposition in place, storing the factorization in the
              lower triangular part of the given matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[][],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Solve(System.Single[],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.InverseDiagonal(System.Boolean)">
            <summary>
              Computes the diagonal of the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.InverseDiagonal(System.Single[],System.Boolean)">
             <summary>
               Computes the diagonal of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             <param name="result">The array to hold the result of the 
                computation. Should be of same length as the diagonal
                of the original matrix.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.InverseTrace(System.Boolean)">
             <summary>
               Computes the trace of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.FromLeftTriangularMatrix(System.Single[][])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.PositiveDefinite">
            <summary>
              Returns <see langword="true"/> if the matrix is positive definite.
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.IsNotDefined">
            <summary>
              Gets a value indicating whether the LDLt factorization
              has been computed successfully or if it is undefined.
            </summary>
            
            <value>
                <c>true</c> if the factorization is not defined; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.LeftTriangularFactor">
            <summary>
              Returns the left (lower) triangular factor
              <c>L</c> so that <c>A = L * D * L'</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.DiagonalMatrix">
            <summary>
              Returns the block diagonal matrix of diagonal
              elements in a LDLt decomposition.
            </summary>        
              
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Diagonal">
            <summary>
              Returns the one-dimensional array of diagonal 
              elements in a LDLt decomposition.
            </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Determinant">
            <summary>
              Returns the determinant of
              the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.LogDeterminant">
            <summary>
              If the matrix is positive-definite, returns the
              log-determinant of the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionF.Nonsingular">
            <summary>
              Gets a value indicating whether the decomposed
              matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Matrix">
             <summary>
               Static class Matrix. Defines a set of extension methods
               that operates mainly on multidimensional arrays and vectors.
             </summary>
             
             
             <remarks>
               The matrix class is a static class containing several extension methods.
               To use this class, import the <see cref="N:Accord.Math"/> and use the
               standard .NET's matrices and jagged arrays. When you call the dot (.)
               operator on those classes, the extension methods offered by this class
               should become available through IntelliSense auto-complete.
             </remarks>
             
             <example>
               <h2>Introduction</h2>
               
               <para>
                 Declaring and using matrices in the Accord.NET Framework does
                 not requires much. In fact, it does not require anything else
                 that is not already present at the .NET Framework. If you have
                 already existing and working code using other libraries, you
                 don't have to convert your matrices to any special format used
                 by Accord.NET. This is because Accord.NET is built to interoperate
                 with other libraries and existing solutions, relying solely on
                 default .NET structures to work.</para>
                 
               <para>
                 To begin, please add the following <c>using</c> directive on
                 top of your .cs (or equivalent) source code file: </para>
                 
               <code>
                 using Accord.Math;
               </code>
               
               <para>
                 This is all you need to start using the Accord.NET matrix library.</para>
                 
               <h2>Creating matrices</h2>
               
               <para>
                 Let's start by declaring a matrix, or otherwise specifying matrices
                 from other sources. The most straightforward way to declare a matrix
                 in Accord.NET is simply using: </para>
                 
             <code>
                 double[,] matrix = 
                 {
                    { 1, 2 },
                    { 3, 4 },
                    { 5, 6 },
                };
             </code>
             
              <para>
                Yep, that is right. You don't need to create any fancy custom Matrix
                classes or vectors to make Accord.NET work, which is a plus if you
                have already existent code using other libraries. You are also free
                to use both the multidimensional matrix syntax above or the jagged
                matrix syntax below:</para>
                
             <code>
                 double[][] matrix = 
                 {
                    new double[] { 1, 2 },
                    new double[] { 3, 4 },
                    new double[] { 5, 6 },
                };
             </code>
             
              <para>
                Special purpose matrices can also be created through specialized methods.
                Those include</para>
                
             <code>
               // Creates a vector of indices
               int[] idx = Matrix.Indices(0, 10);  // { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
               
               // Creates a step vector within a given interval
               double[] interval = Matrix.Interval(from: -2, to: 4); // { -2, -1, 0, 1, 2, 3, 4 };
               
               // Special matrices
               double[,] I = Matrix.Identity(3);     // creates a 3x3 identity matrix
               double[,] magic = Matrix.Magic(5);    // creates a magic square matrix of size 5
               
               double[] v = Matrix.Vector(5, 1.0);      // generates { 1, 1, 1, 1, 1 }
               double[,] diagonal = Matrix.Diagonal(v); // matrix with v on its diagonal
             </code>
                
              <para>
                Another way to declare matrices is by parsing the contents of a string:</para>
                
             <code>
               string str = @"1 2
                              3 4";
                              
               double[,] matrix = Matrix.Parse(str);
             </code>
             
              <para>
                You can even read directly from matrices formatted in C# syntax:</para>
                
              <code>
               string str = @"double[,] matrix = 
                              {
                                 { 1, 2 },
                                 { 3, 4 },
                                 { 5, 6 },
                              }";
                              
               matrix[,] mdimensional = Matrix.Parse(str, CSharpMatrixFormatProvider.InvariantCulture);
               matrix[,] jagged = Matrix.ParseJagged(str, CSharpMatrixFormatProvider.InvariantCulture);
              </code>
              
              <para>
                And even from <a href="http://www.gnu.org/software/octave/">Octave-compatible</a> syntax!</para>
                
              <code>
               string str = "[1 2; 3 4]";
                              
               matrix[,] matrix = Matrix.Parse(str, OctaveMatrixFormatProvider.InvariantCulture);
              </code>
              
              <para>
                There are also other methods, such as specialization for arrays and other formats.
                For more details, please take a look on <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
                <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>, <see cref="T:Accord.Math.DefaultArrayFormatProvider"/>,
                <see cref="T:Accord.Math.DefaultMatrixFormatProvider"/> and <see cref="M:Accord.Math.Matrix.Parse(System.String)"/>.
              </para>
                
                 
              <h2>Matrix operations</h2>
              
              <para>
                Albeit being simple <see cref="T:double[]"/> matrices, the framework leverages
                .NET extension methods to support all basic matrix operations. For instance,
                consider the elementwise operations (also known as dot operations in Octave):</para>
             
             <code>
               double[] vector = { 0, 2, 4 };
               double[] a = vector.ElementwiseMultiply(2); // vector .* 2, generates { 0,  4,  8 }
               double[] b = vector.ElementwiseDivide(2);   // vector ./ 2, generates { 0,  1,  2 }
               double[] c = vector.ElementwisePower(2);    // vector .^ 2, generates { 0,  4, 16 }
             </code>
             
             <para>
               Operations between vectors, matrices, and both are also completely supported:</para>
               
             <code>
               // Declare two vectors
               double[] u = { 1, 6, 3 };
               double[] v = { 9, 4, 2 };
             
               // Products between vectors
               double inner = u.InnerProduct(v);    // 39.0
               double[,] outer = u.OuterProduct(v); // see below
               double[] kronecker = u.KroneckerProduct(v); // { 9, 4, 2, 54, 24, 12, 27, 12, 6 }
               double[][] cartesian = u.CartesianProduct(v); // all possible pair-wise combinations
             
             /* outer =
                { 
                   {  9,  4,  2 },
                   { 54, 24, 12 },
                   { 27, 12,  6 },
                };                  */
            
               // Addition
               double[] addv = u.Add(v); // { 10, 10, 5 }
               double[] add5 = u.Add(5); // {  6, 11, 8 }
            
               // Elementwise operations
               double[] abs = u.Abs();   // { 1, 6, 3 }
               double[] log = u.Log();   // { 0, 1.79, 1.09 }
               
               // Apply *any* function to all elements in a vector
               double[] cos = u.Apply(Math.Cos); // { 0.54, 0.96, -0.989 }
               u.ApplyInPlace(Math.Cos); // can also do optionally in-place
            
               
               // Declare a matrix
               double[,] M = 
               {
                  { 0, 5, 2 },
                  { 2, 1, 5 }
               };
              
               // Extract a subvector from v:
               double[] vcut = v.Submatrix(0, 1); // { 9, 4 }
               
               // Some operations between vectors and matrices
               double[] Mv = m.Multiply(v);    //  { 24, 32 }
               double[] vM = vcut.Multiply(m); // { 8, 49, 38 }
               
               // Some operations between matrices
               double[,] Md = m.MultiplyByDiagonal(v);   // { { 0, 20, 4 }, { 18, 4, 10 } }
               double[,] MMt = m.MultiplyByTranspose(m); //   { { 29, 15 }, { 15, 30 } }
             </code>
             
             <para>
               Please note this is by no means an extensive list; please take a look on
               all members available on this class or (preferably) use IntelliSense to
               navigate through all possible options when trying to perform an operation.</para>
             </example>
             
             <seealso cref="T:Accord.Math.DefaultMatrixFormatProvider"/>
             <seealso cref="T:Accord.Math.DefaultArrayFormatProvider"/>
             <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
             <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
             <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
             <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
             
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="startRow">Start row index</param>
            <param name="endRow">End row index</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="destination">The matrix where results should be stored.</param>
            <param name="startRow">Start row index</param>
            <param name="endRow">End row index</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32[],System.Int32[])">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],``0[0:,0:],System.Int32[],System.Int32[])">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="destination">The matrix where results should be stored.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32[])">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32,System.Int32,System.Int32[])">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="startRow">Starting row index</param>
            <param name="endRow">End row index</param>
            <param name="columnIndexes">Array of column indices</param>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[0:,0:],System.Int32[],System.Int32,System.Int32)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="startRow">Start row index</param>
            <param name="endRow">End row index</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32[],System.Int32[],System.Boolean)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            <param name="reuseMemory">Set to true to avoid memory allocations 
              when possible. This might result on the shallow copies of some
              elements. Default is false (default is to always provide a true,
              deep copy of every element in the matrices, using more memory).</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32[],System.Boolean)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="indexes">Array of indices.</param>
            <param name="transpose">True to return a transposed matrix; false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32[],System.Int32,System.Int32,System.Boolean)">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
            <param name="reuseMemory">Set to true to avoid memory allocations 
              when possible. This might result on the shallow copies of some
              elements. Default is false (default is to always provide a true,
              deep copy of every element in the matrices, using more memory).</param>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[][],System.Int32,System.Int32,System.Int32[])">
            <summary>
              Returns a sub matrix extracted from the current matrix.
            </summary>
            
            <param name="source">The matrix to return the submatrix from.</param>
            <param name="startRow">Starting row index</param>
            <param name="endRow">End row index</param>
            <param name="columnIndexes">Array of column indices</param>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[],System.Int32[])">
            <summary>
              Returns a subvector extracted from the current vector.
            </summary>
            
            <param name="source">The vector to return the subvector from.</param>
            <param name="indexes">Array of indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[],System.Int32,System.Int32)">
            <summary>
              Returns a subvector extracted from the current vector.
            </summary>
            
            <param name="source">The vector to return the subvector from.</param>
            <param name="startRow">Starting index.</param>
            <param name="endRow">End index.</param>
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(``0[],System.Int32)">
            <summary>
              Returns a subvector extracted from the current vector.
            </summary>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Submatrix``1(System.Collections.Generic.List{``0},System.Int32[])">
            <summary>
              Returns a subvector extracted from the current vector.
            </summary>
            
            <param name="source">The vector to return the subvector from.</param>
            <param name="indexes">Array of indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subgroups``1(``0[],System.Int32[])">
            <summary>
              Returns subgroups extracted from the given vector.
            </summary>
            
            <param name="values">The vector to extract the groups from.</param>
            <param name="groups">The vector of indices for the groups.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subgroups``1(``0[],System.Int32[],System.Int32)">
            <summary>
              Returns subgroups extracted from the given vector, assuming that
              the groups should have been labels from 0 until the given number
              of <paramref name="classes"/>.
            </summary>
            
            <param name="values">The vector to extract the groups from.</param>
            <param name="groups">The vector of indices for the groups.</param>
            <param name="classes">The number of classes in the groups. Specifying this
              parameter will make the method assume the groups should be containing
              integer labels ranging from 0 until the number of classes.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.submatrix``1(``0[0:,0:],``0[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
              Extracts a selected area from a matrix.
            </summary>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.submatrix``1(``0[0:,0:],``0[0:,0:],System.Int32[],System.Int32[])">
            <summary>
              Extracts a selected area from a matrix.
            </summary>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.submatrix``1(``0[][],``0[][],System.Int32[],System.Int32[],System.Boolean)">
            <summary>
              Extracts a selected area from a matrix.
            </summary>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.submatrix``1(``0[][],``0[][],System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
              Extracts a selected area from a matrix.
            </summary>
            
            <remarks>
              Routine adapted from Lutz Roeder's Mapack for .NET, September 2000.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Create``1(System.Int32,System.Int32,``0)">
            <summary>
              Returns a matrix with all elements set to a given value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Create``1(System.Int32,``0)">
            <summary>
              Returns a matrix with all elements set to a given value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Create``1(System.Int32,System.Int32)">
            <summary>
              Returns a new multidimensional matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Create``1(System.Int32)">
            <summary>
              Returns a new multidimensional matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Jagged``1(System.Int32,System.Int32,``0)">
            <summary>
              Returns a matrix with all elements set to a given value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Jagged``1(System.Int32,``0)">
            <summary>
              Returns a matrix with all elements set to a given value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Jagged``1(System.Int32,System.Int32)">
            <summary>
              Returns a new jagged matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Jagged``1(System.Int32)">
            <summary>
              Returns a new jagged matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,``0)">
            <summary>
              Returns a square diagonal matrix of the given size.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,System.Int32,``0)">
            <summary>
              Returns a matrix of the given size with value on its diagonal.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(``0[])">
            <summary>
              Return a square matrix with a vector of values on its diagonal.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,``0[])">
            <summary>
              Return a square matrix with a vector of values on its diagonal.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(System.Int32,System.Int32,``0[])">
            <summary>
              Returns a matrix with a vector of values on its diagonal.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Identity(System.Int32)">
            <summary>
              Returns the Identity matrix of the given size.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Magic(System.Int32)">
            <summary>
              Creates a magic square matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Centering(System.Int32)">
            <summary>
              Creates a centering matrix of size <c>N x N</c> in the
              form <c>(I - 1N)</c> where <c>1N</c> is a matrix with 
              all elements equal to <c>1 / N</c>.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Int32)">
            <summary>
              Creates a rows-by-cols matrix with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Boolean,System.Double,System.Double)">
            <summary>
              Creates a rows-by-cols matrix with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
              Creates a rows-by-cols matrix with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Int32,AForge.Math.Random.IRandomNumberGenerator)">
            <summary>
              Creates a rows-by-cols matrix random data drawn from a given distribution.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Single,System.Single)">
            <summary>
              Creates a vector with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,System.Double,System.Double)">
            <summary>
              Creates a vector with uniformly distributed random data.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Random(System.Int32,AForge.Math.Random.IRandomNumberGenerator)">
            <summary>
              Creates a vector with random data drawn from a given distribution.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.RowVector``1(``0[])">
            <summary>
              Creates a matrix with a single row vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ColumnVector``1(``0[])">
            <summary>
              Creates a matrix with a single column vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Vector``1(System.Int32,``0[])">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Vector``1(System.Int32,``0)">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Vector(System.Double,System.Double,System.Double)">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Vector(System.Int32,System.Int32,System.Int32)">
            <summary>
              Creates a vector with the given dimension and starting values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Indices(System.Int32,System.Int32)">
            <summary>
              Creates a index vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Int32,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(AForge.DoubleRange,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Double,System.Double,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Single,System.Single,System.Double)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(AForge.DoubleRange,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Interval(System.Double,System.Double,System.Int32)">
            <summary>
              Creates an interval vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Mesh(AForge.DoubleRange,AForge.DoubleRange,System.Double,System.Double)">
            <summary>
              Creates a bi-dimensional mesh matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.MeshGrid``1(``0[],``0[])">
             <summary>
               Generates a 2-D mesh grid from two vectors <c>a</c> and <c>b</c>,
               generating two matrices <c>len(a)</c> x <c>len(b)</c> with all
               all possible combinations of values between the two vectors.
             </summary>
            
             <returns>A tuple containing two matrices: the first containing values
             for the x-coordinates and the second for the y-coordinates.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[],``0[])">
            <summary>
              Combines two vectors horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[],``0)">
            <summary>
              Combines a vector and a element horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0,``0[])">
            <summary>
              Combines a vector and a element horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[0:,0:],``0[])">
            <summary>
              Combines a matrix and a vector horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[0:,0:],``0[0:,0:])">
            <summary>
              Combines two matrices horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[][],``0[][])">
            <summary>
              Combines two matrices horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[][0:,0:])">
            <summary>
              Combines a matrix and a vector horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[][][])">
            <summary>
              Combines a matrix and a vector horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Concatenate``1(``0[][])">
            <summary>
              Combine vectors horizontally.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[][])">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[])">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[],``0)">
            <summary>
              Combines vectors vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[][0:,0:])">
            <summary>
              Combines matrices vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[0:,0:],``0[])">
            <summary>
              Combines matrices vertically.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Stack``1(``0[][][])">
            <summary>
              Combines matrices vertically.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Expand``1(``0[],System.Int32[])">
            <summary>
              Expands a data vector given in summary form.
            </summary>
            <param name="vector">A base vector.</param>
            <param name="count">An array containing by how much each line should be replicated.</param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.Expand``1(``0[0:,0:],System.Int32[])">
            <summary>
              Expands a data matrix given in summary form.
            </summary>
            <param name="matrix">A base matrix.</param>
            <param name="count">An array containing by how much each line should be replicated.</param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.Split``1(``0[],System.Int32)">
            <summary>
              Splits a given vector into a smaller vectors of the given size.
              This operation can be reverted using <see cref="M:Accord.Math.Matrix.Merge``1(``0[][],System.Int32)"/>.
            </summary>
            
            <param name="vector">The vector to be splitted.</param>
            <param name="size">The size of the resulting vectors.</param>
            
            <returns>An array of vectors containing the subdivisions of the given vector.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Merge``1(``0[][],System.Int32)">
            <summary>
              Merges a series of vectors into a single vector. This
              operation can be reverted using <see cref="M:Accord.Math.Matrix.Split``1(``0[],System.Int32)"/>.
            </summary>
            
            <param name="vectors">The vectors to be merged.</param>
            <param name="size">The size of the inner vectors.</param>
            
            <returns>A single array containing the given vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[][])">
            <summary>
              Converts a jagged-array into a multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[][],System.Boolean)">
            <summary>
              Converts a jagged-array into a multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[])">
            <summary>
              Converts an array into a multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(``0[],System.Boolean)">
            <summary>
              Converts an array into a multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(``0[],System.Boolean)">
            <summary>
              Converts an array into a multidimensional array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(``0[0:,0:])">
            <summary>
              Converts a multidimensional array into a jagged array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(``0[0:,0:],System.Boolean)">
            <summary>
              Converts a multidimensional array into a jagged array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Single[0:,0:])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a single-precision floating point multidimensional
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Int32[0:,0:])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a single-precision floating point multidimensional
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToSingle(System.Double[0:,0:])">
            <summary>
              Converts a single-precision floating point multidimensional
              array into a double-precision floating point multidimensional
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.Double[0:,0:])">
            <summary>
              Truncates a double matrix to integer values.
            </summary>
            <param name="matrix">The matrix to be truncated.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.Double[][])">
            <summary>
              Truncates a double matrix to integer values.
            </summary>
            <param name="matrix">The matrix to be truncated.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Int32[][])">
            <summary>
              Truncates an integer matrix to double values.
            </summary>
            <param name="matrix">The matrix to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Single[])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a single-precision floating point multidimensional
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Int16[])">
            <summary>
              Converts a double-precision floating point multidimensional
              array into a single-precision floating point multidimensional
              array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32(System.Double[])">
            <summary>
              Truncates a double vector to integer values.
            </summary>
            <param name="vector">The vector to be truncated.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToDouble(System.Int32[])">
            <summary>
              Converts a integer vector into a double vector.
            </summary>
            <param name="vector">The vector to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToSingle(System.Double[])">
            <summary>
              Converts a double vector into a single vector.
            </summary>
            <param name="vector">The vector to be converted.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convert``2(``0[],System.Converter{``0,``1})">
            <summary>
              Converts the values of a vector using the given converter expression.
            </summary>
            <typeparam name="TInput">The type of the input.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <param name="vector">The vector to be converted.</param>
            <param name="converter">The converter function.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convert``2(``0[][],System.Converter{``0,``1})">
            <summary>
              Converts the values of a matrix using the given converter expression.
            </summary>
            <typeparam name="TInput">The type of the input.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <param name="matrix">The matrix to be converted.</param>
            <param name="converter">The converter function.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convert``2(``0[0:,0:],System.Converter{``0,``1})">
            <summary>
              Converts the values of a matrix using the given converter expression.
            </summary>
            <typeparam name="TInput">The type of the input.</typeparam>
            <typeparam name="TOutput">The type of the output.</typeparam>
            <param name="matrix">The vector to be converted.</param>
            <param name="converter">The converter function.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix(System.Data.DataTable)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix(System.Data.DataTable,System.String[]@)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(System.Data.DataTable,System.String[]@)">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToMatrix``1(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Double[0:,0:])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Double[0:,0:],System.String[])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Double[][])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToTable(System.Double[][],System.String[])">
            <summary>
              Converts a DataTable to a double[,] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable,System.IFormatProvider)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable,System.String[]@)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable,System.String[]@,System.IFormatProvider)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable,System.String[]@)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable,System.String[]@,System.IFormatProvider)">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a double[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataColumn)">
            <summary>
              Converts a DataColumn to a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataColumn)">
            <summary>
              Converts a DataColumn to a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataRow,System.String[])">
            <summary>
              Converts a DataColumn to a generic array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray(System.Data.DataRow,System.String[])">
            <summary>
              Converts a DataColumn to a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToArray``1(System.Data.DataTable,System.String)">
            <summary>
              Converts a DataTable to a int[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToInt32Array(System.Data.DataColumn)">
            <summary>
              Converts a DataColumn to a int[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToIntArray(System.Data.DataTable,System.String[])">
            <summary>
              Converts a DataTable to a int[][] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsRelativelyEqual(System.Double,System.Double,System.Double)">
            <summary>
              Compares two values for equality, considering a relative acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[0:,0:],System.Double[0:,0:],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Single[0:,0:],System.Single[0:,0:],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[][],System.Double[][],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Single[][],System.Single[][],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[],System.Double[],System.Double)">
            <summary>
              Compares two vectors for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Single[],System.Single[],System.Double)">
            <summary>
              Compares two vectors for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[],System.Double)">
            <summary>
              Compares each member of a vector for equality with a scalar value x.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual(System.Double[0:,0:],System.Double)">
            <summary>
              Compares each member of a matrix for equality with a scalar value x.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual``1(``0[][],``0[][])">
            <summary>
              Compares two matrices for equality.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual``1(``0[0:,0:],``0[0:,0:])">
            <summary>Compares two matrices for equality.</summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsEqual``1(``0[],``0[])">
            <summary>Compares two vectors for equality.</summary>
        </member>
        <member name="M:Accord.Math.Matrix.Equals(System.Object)">
            <summary>
              This method should not be called. Use Matrix.IsEqual instead.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasNaN(System.Double[0:,0:])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a value that is not a number (NaN).
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a value that is not a number, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasNaN(System.Double[])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a value that is not a number (NaN).
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a value that is not a number, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasNaN(System.Double[][])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a value that is not a number (NaN).
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a value that is not a number, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasInfinity(System.Double[0:,0:])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a infinity value.
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains infinity values, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasInfinity(System.Double[])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a infinity value.
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a infinity value, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.HasInfinity(System.Double[][])">
            <summary>
              Returns a value indicating whether the specified
              matrix contains a infinity value.
            </summary>
            
            <param name="matrix">A double-precision multidimensional matrix.</param>
            
            <returns>True if the matrix contains a infinity value, false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[0:,0:])">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
            <returns>The transpose of the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[][])">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
            <returns>The transpose of the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[0:,0:],System.Boolean)">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
            <param name="inPlace">True to store the transpose over the same input
              <paramref name="matrix"/>, false otherwise. Default is false.</param>
            <returns>The transpose of the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[][],System.Boolean)">
            <summary>
              Gets the transpose of a matrix.
            </summary>
            <param name="matrix">A matrix.</param>
            <param name="inPlace">True to store the transpose over the same input
              <paramref name="matrix"/>, false otherwise. Default is false.</param>
            <returns>The transpose of the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Transpose``1(``0[])">
            <summary>
              Gets the transpose of a row vector.
            </summary>
            <param name="rowVector">A row vector.</param>
            <returns>The transpose of the given vector.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsSorted``1(``0[],Accord.Math.Comparers.ComparerDirection)">
            <summary>
              Returns true if a vector of real-valued observations
              is ordered in ascending or descending order.
            </summary>
            
            <param name="values">An array of values.</param>
            <param name="direction">The sort order direction.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsSquare``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is square.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.IsSymmetric``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is symmetric.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsUpperTriangular``1(``0[][])">
            <summary>
              Returns true if a matrix is upper triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsLowerTriangular``1(``0[][])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsUpperTriangular``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is upper triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsLowerTriangular``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsDiagonal``1(``0[0:,0:])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsDiagonal``1(``0[][])">
            <summary>
              Returns true if a matrix is lower triangular.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.IsSymmetric``1(``0[][])">
            <summary>
              Returns true if a matrix is symmetric.
            </summary>
            <param name="matrix"></param>
            <returns></returns>
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Double[0:,0:])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Gets the trace of a matrix product.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Int32[0:,0:])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Single[0:,0:])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Trace(System.Single[][])">
            <summary>
              Gets the trace of a matrix.
            </summary>
            
            <remarks>
              The trace of an n-by-n square matrix A is defined to be the sum of the
              elements on the main diagonal (the diagonal from the upper left to the
              lower right) of A.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(``0[][])">
            <summary>
              Gets the diagonal vector from a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            
            <returns>The diagonal vector from the given matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Diagonal``1(``0[0:,0:])">
            <summary>
              Gets the diagonal vector from a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            
            <returns>The diagonal vector from the given matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Determinant(System.Double[0:,0:])">
            <summary>
              Gets the determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Determinant(System.Double[0:,0:],System.Boolean)">
            <summary>
              Gets the determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.LogDeterminant(System.Double[0:,0:])">
            <summary>
              Gets the log-determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.LogDeterminant(System.Double[0:,0:],System.Boolean)">
            <summary>
              Gets the log-determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.PseudoDeterminant(System.Double[0:,0:])">
            <summary>
              Gets the pseudo-determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.LogPseudoDeterminant(System.Double[0:,0:])">
            <summary>
              Gets the log of the pseudo-determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Rank(System.Double[0:,0:])">
            <summary>
              Gets the determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Rank(System.Single[0:,0:])">
            <summary>
              Gets the determinant of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsSingular(System.Double[0:,0:])">
            <summary>
               Gets whether a matrix is singular.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsPositiveDefinite(System.Double[0:,0:])">
            <summary>
               Gets whether a matrix is positive definite.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.IsPositiveDefinite(System.Double[][])">
            <summary>
               Gets whether a matrix is positive definite.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Single[0:,0:])">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[0:,0:])">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Single[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[][])">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[][],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Int32[0:,0:])">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Int32[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the sum will be calculated. Default is 0.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Double[])">
            <summary>
              Gets the sum of all elements in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Single[])">
            <summary>
              Gets the sum of all elements in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sum(System.Int32[])">
            <summary>
              Gets the sum of all elements in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.CumulativeSum(System.Double[])">
            <summary>Calculates a vector cumulative sum.</summary>
        </member>
        <member name="M:Accord.Math.Matrix.CumulativeSum(System.Double[0:,0:],System.Int32)">
            <summary>Calculates the matrix Sum vector.</summary>
            <param name="matrix">A matrix whose sums will be calculated.</param>
            <param name="dimension">The dimension in which the cumulative sum will be calculated.</param>
            <returns>Returns a vector containing the sums of each variable in the given matrix.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Product(System.Double[])">
            <summary>
              Gets the product of all elements in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Product(System.Int32[])">
            <summary>
              Gets the product of all elements in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[],System.Func{``0,``0})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[],System.Func{``0,System.Int32,``0})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[0:,0:],System.Func{``0,``0})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyInPlace``1(``0[0:,0:],System.Func{``0,System.Int32,System.Int32,``0})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Apply``2(``0[],System.Func{``0,``1})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyWithIndex``2(``0[],System.Func{``0,System.Int32,``1})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Apply``2(``0[0:,0:],System.Func{``0,``1})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ApplyWithIndex``2(``0[0:,0:],System.Func{``0,System.Int32,System.Int32,``1})">
            <summary>
              Applies a function to every element of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Apply``2(System.Collections.Generic.IList{``0},System.Func{``0,``1})">
            <summary>
              Applies a function to every element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Round(System.Double[0:,0:],System.Int32)">
            <summary>
              Rounds a double-precision floating-point matrix to a specified number of fractional digits.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Floor(System.Double[0:,0:])">
            <summary>
              Returns the largest integer less than or equal than to the specified 
              double-precision floating-point number for each element of the matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Ceiling(System.Double[0:,0:])">
            <summary>
              Returns the largest integer greater than or equal than to the specified 
              double-precision floating-point number for each element of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Round(System.Double[],System.Int32)">
            <summary>
              Rounds a double-precision floating-point number array to a specified number of fractional digits.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Floor(System.Double[])">
            <summary>
              Returns the largest integer less than or equal than to the specified 
              double-precision floating-point number for each element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Ceiling(System.Double[])">
            <summary>
              Returns the largest integer greater than or equal than to the specified 
              double-precision floating-point number for each element of the array.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[],System.Int32,System.Int32)">
            <summary>
              Transforms a vector into a matrix of given dimensions.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[0:,0:])">
            <summary>
              Transforms a matrix into a single vector.
            </summary>
            
            <param name="matrix">A matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[0:,0:],System.Int32)">
            <summary>
              Transforms a matrix into a single vector.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="dimension">The direction to perform copying. Pass
            0 to perform a row-wise copy. Pass 1 to perform a column-wise
            copy. Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[][])">
            <summary>
              Transforms a jagged array matrix into a single vector.
            </summary>
            <param name="array">A jagged array.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Reshape``1(``0[][],System.Int32)">
            <summary>
              Transforms a jagged array matrix into a single vector.
            </summary>
            
            <param name="array">A jagged array.</param>
            <param name="dimension">The direction to perform copying. Pass
            0 to perform a row-wise copy. Pass 1 to perform a column-wise
            copy. Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convolve(System.Double[],System.Double[])">
            <summary>
              Convolves an array with the given kernel.
            </summary>
            
            <param name="a">A floating number array.</param>
            <param name="kernel">A convolution kernel.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Convolve(System.Double[],System.Double[],System.Boolean)">
            <summary>
            Convolves an array with the given kernel.
            </summary>
            
            <param name="a">A floating number array.</param>
            <param name="kernel">A convolution kernel.</param>
            <param name="trim">
              If <c>true</c> the resulting array will be trimmed to
              have the same length as the input array. Default is false.</param>
              
        </member>
        <member name="M:Accord.Math.Matrix.MemberwiseClone``1(``0[][])">
            <summary>
              Creates a memberwise copy of a jagged matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Single[][])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Double[][])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>A*B</c> of two matrices <c>A</c> and <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[][],System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Single[][],System.Single[][])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[][],System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>R = A*B</c> of two matrices <c>A</c>
              and <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and transpose of <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <returns>The product <c>A*B'</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and
              transpose of <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
               
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByTranspose(System.Single[0:,0:],System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Computes the product <c>A*B'</c> of matrix <c>A</c> and
              transpose of <c>B</c>, storing the result in matrix <c>R</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The transposed right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B'</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
               
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <returns>The product <c>A'*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[][],System.Double[][],System.Double[][])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and matrix <c>B</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A'*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product <c>A'*B</c> of matrix <c>A</c> transposed and vector <c>b</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right column vector <c>b</c>.</param>
            <returns>The product <c>A'*b</c> of the given matrices <c>A</c> and vector <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiply(System.Double[0:,0:],System.Double[],System.Double[])">
            <summary>
              Computes the product <c>A'*b</c> of matrix <c>A</c> transposed and column vector <c>b</c>.
            </summary>
            
            <param name="a">The transposed left matrix <c>A</c>.</param>
            <param name="b">The right column vector <c>b</c>.</param>
            <param name="result">The vector <c>r</c> to store the product <c>r = A'*b</c>
              of the given matrix <c>A</c> and vector <c>b</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiplyByDiagonal(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TransposeAndMultiplyByDiagonal(System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Computes the product A'*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Single[0:,0:],System.Single[])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.MultiplyByDiagonal(System.Single[0:,0:],System.Single[],System.Single[0:,0:])">
            <summary>
              Computes the product A*B of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.DivideByDiagonal(System.Double[0:,0:],System.Double[])">
            <summary>
              Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of inverse right matrix <c>B</c>.</param>
            <returns>The product <c>A*B</c> of the given matrices <c>A</c> and <c>B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.DivideByDiagonal(System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Computes the product A*inv(B) of matrix <c>A</c> and diagonal matrix <c>B</c>.
            </summary>
            
            <param name="a">The left matrix <c>A</c>.</param>
            <param name="b">The diagonal vector of inverse right matrix <c>B</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R = A*B</c>
              of the given matrices <c>A</c> and <c>B</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[],System.Double[0:,0:])">
            <summary>
              Multiplies a row vector <c>v</c> and a matrix <c>A</c>,
              giving the product <c>v'*A</c>.
            </summary>
            
            <param name="rowVector">The row vector <c>v</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>v'*A</c>of the multiplication of the
              given row vector <c>v</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[],System.Single[0:,0:])">
            <summary>
              Multiplies a row vector <c>v</c> and a matrix <c>A</c>,
              giving the product <c>v'*A</c>.
            </summary>
            
            <param name="rowVector">The row vector <c>v</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>v'*A</c>of the multiplication of the
              given row vector <c>v</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double[])">
            <summary>
              Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
              giving the product <c>A*v</c>
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="columnVector">The column vector <c>v</c>.</param>
            <returns>The product <c>A*v</c> of the multiplication of the
              given matrix <c>A</c> and column vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[][],System.Double[])">
            <summary>
              Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
              giving the product <c>A*v</c>
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="columnVector">The column vector <c>v</c>.</param>
            <returns>The product <c>A*v</c> of the multiplication of the
              given matrix <c>A</c> and column vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single[])">
            <summary>
              Multiplies a matrix <c>A</c> and a column vector <c>v</c>,
              giving the product <c>A*v</c>
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="columnVector">The column vector <c>v</c>.</param>
            <returns>The product <c>A*v</c> of the multiplication of the
              given matrix <c>A</c> and column vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double,System.Boolean)">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="inPlace">True to perform the operation in-place,
              overwriting the original matrix; false to return a new matrix.</param>
            
            <returns>The product <c>A*x</c> of the multiplication of the
              given matrix <c>A</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double)">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <returns>The product <c>A*x</c> of the multiplication of the
              given matrix <c>A</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single)">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <returns>The product <c>A*x</c> of the multiplication of the
              given matrix <c>A</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[0:,0:],System.Double,System.Double[0:,0:])">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R=A*x</c>
              of the multiplication of the given matrix <c>A</c> and scalar <c>x</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[0:,0:],System.Single,System.Single[0:,0:])">
            <summary>
              Multiplies a matrix <c>A</c> by a scalar <c>x</c>.
            </summary>
            
            <param name="matrix">The matrix <c>A</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="result">The matrix <c>R</c> to store the product <c>R=A*x</c>
              of the multiplication of the given matrix <c>A</c> and scalar <c>x</c>.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double[],System.Double)">
            <summary>
              Multiplies a vector <c>v</c> by a scalar <c>x</c>.
            </summary>
            <param name="vector">The vector <c>v</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <returns>The product <c>v*x</c> of the multiplication of the 
              given vector <c>v</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single[],System.Single)">
            <summary>
              Multiplies a vector <c>v</c> by a scalar <c>x</c>.
            </summary>
            <param name="vector">The vector <c>v</c>.</param>
            <param name="x">The scalar <c>x</c>.</param>
            <returns>The product <c>v*x</c> of the multiplication of the 
              given vector <c>v</c> and scalar <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double,System.Double[0:,0:])">
            <summary>
              Multiplies a scalar <c>x</c> by a matrix <c>A</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>x*A</c> of the multiplication of the
              given scalar <c>x</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single,System.Single[0:,0:])">
            <summary>
              Multiplies a scalar <c>x</c> by a matrix <c>A</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="matrix">The matrix <c>A</c>.</param>
            <returns>The product <c>x*A</c> of the multiplication of the
              given scalar <c>x</c> and matrix <c>A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Double,System.Double[])">
            <summary>
              Multiplies a scalar <c>x</c> by a vector <c>v</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="vector">The vector <c>v</c>.</param>
            <returns>The product <c>x*v</c> of the multiplication of the 
              given scalar <c>x</c> and vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Single,System.Single[])">
            <summary>
              Multiplies a scalar <c>x</c> by a vector <c>v</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="vector">The vector <c>v</c>.</param>
            <returns>The product <c>x*v</c> of the multiplication of the 
              given scalar <c>x</c> and vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Int32,System.Double[])">
            <summary>
              Multiplies a scalar <c>x</c> by a vector <c>v</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="vector">The vector <c>v</c>.</param>
            <returns>The product <c>x*v</c> of the multiplication of the 
              given scalar <c>x</c> and vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Multiply(System.Int32,System.Single[])">
            <summary>
              Multiplies a scalar <c>x</c> by a vector <c>v</c>.
            </summary>
            <param name="x">The scalar <c>x</c>.</param>
            <param name="vector">The vector <c>v</c>.</param>
            <returns>The product <c>x*v</c> of the multiplication of the 
              given scalar <c>x</c> and vector <c>v</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double,System.Double[],System.Boolean)">
            <summary>
              Divides a scalar by a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Int32,System.Double[],System.Boolean)">
            <summary>
              Divides a scalar by a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double[],System.Double,System.Boolean)">
            <summary>
              Divides a vector by a scalar.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Int32[],System.Double)">
            <summary>
              Divides a vector by a scalar.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Single[],System.Single)">
            <summary>
              Divides a vector by a scalar.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given vector <c>a</c> and scalar <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double,System.Double[])">
            <summary>
              Elementwise divides a scalar by a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given scalar <c>a</c> and vector <c>b</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Divides two matrices by multiplying A by the inverse of B.
            </summary>
            
            <param name="a">The first matrix.</param>
            <param name="b">The second matrix (which will be inverted).</param>
            
            <returns>The result from the division <c>AB^-1</c> of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double[0:,0:],System.Double,System.Boolean)">
            <summary>
              Divides a matrix by a scalar.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
            <returns>The division quotient of the given matrix and scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.UInt32[0:,0:],System.Single)">
            <summary>
              Divides a matrix by a scalar.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="x">A scalar.</param>
            
            <returns>The division quotient of the given matrix and scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Double,System.Double[0:,0:])">
            <summary>
              Elementwise divides a scalar by a matrix.
            </summary>
            
            <param name="x">A scalar.</param>
            <param name="matrix">A matrix.</param>
            
            <returns>The elementwise division of the given scalar and matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Divide(System.Int32,System.Double[0:,0:])">
            <summary>
              Elementwise divides a scalar by a matrix.
            </summary>
            
            <param name="x">A scalar.</param>
            <param name="matrix">A matrix.</param>
            
            <returns>The elementwise division of the given scalar and matrix.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.InnerProduct(System.Double[],System.Double[])">
            <summary>
              Gets the inner product (scalar product) between two vectors (a'*b).
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The inner product of the multiplication of the vectors.</returns>
            
            <remarks>
             <para>
               In mathematics, the dot product is an algebraic operation that takes two
               equal-length sequences of numbers (usually coordinate vectors) and returns
               a single number obtained by multiplying corresponding entries and adding up
               those products. The name is derived from the dot that is often used to designate
               this operation; the alternative name scalar product emphasizes the scalar
               (rather than vector) nature of the result.</para>
             <para>
               The principal use of this product is the inner product in a Euclidean vector space:
               when two vectors are expressed on an orthonormal basis, the dot product of their 
               coordinate vectors gives their inner product.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.InnerProduct(System.Single[],System.Single[])">
            <summary>
              Gets the inner product (scalar product) between two vectors (a'*b).
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The inner product of the multiplication of the vectors.</returns>
            
            <remarks>
             <para>
               In mathematics, the dot product is an algebraic operation that takes two
               equal-length sequences of numbers (usually coordinate vectors) and returns
               a single number obtained by multiplying corresponding entries and adding up
               those products. The name is derived from the dot that is often used to designate
               this operation; the alternative name scalar product emphasizes the scalar
               (rather than vector) nature of the result.</para>
             <para>
               The principal use of this product is the inner product in a Euclidean vector space:
               when two vectors are expressed on an orthonormal basis, the dot product of their 
               coordinate vectors gives their inner product.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.OuterProduct(System.Double[],System.Double[])">
            <summary>
              Gets the outer product (matrix product) between two vectors (a*bT).
            </summary>
            
            <remarks>
              In linear algebra, the outer product typically refers to the tensor
              product of two vectors. The result of applying the outer product to
              a pair of vectors is a matrix. The name contrasts with the inner product,
              which takes as input a pair of vectors and produces a scalar.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.VectorProduct(System.Double[],System.Double[])">
            <summary>
              Vector product.
            </summary>
            
            <remarks>
              The cross product, vector product or Gibbs vector product is a binary operation
              on two vectors in three-dimensional space. It has a vector result, a vector which
              is always perpendicular to both of the vectors being multiplied and the plane
              containing them. It has many applications in mathematics, engineering and physics.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.VectorProduct(System.Single[],System.Single[])">
            <summary>
              Vector product.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.CartesianProduct``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
              Computes the Cartesian product of many sets.
            </summary>
            
            <remarks>
              References:
              - http://blogs.msdn.com/b/ericlippert/archive/2010/06/28/computing-a-Cartesian-product-with-linq.aspx 
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Matrix.CartesianProduct``1(``0[][])">
            <summary>
              Computes the Cartesian product of many sets.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.CartesianProduct``1(``0[],``0[])">
            <summary>
              Computes the Cartesian product of two sets.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.KroneckerProduct(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Computes the Kronecker product between two matrices.
            </summary>
            
            <param name="a">The left matrix a.</param>
            <param name="b">The right matrix b.</param>
            
            <returns>The Kronecker product of the two matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.KroneckerProduct(System.Double[],System.Double[])">
            <summary>
              Computes the Kronecker product between two vectors.
            </summary>
            
            <param name="a">The left vector a.</param>
            <param name="b">The right vector b.</param>
            
            <returns>The Kronecker product of the two vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[0:,0:],System.Double)">
            <summary>
              Adds a scalar to each element of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double,System.Double[0:,0:])">
            <summary>
              Subtracts a scalar to each element of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Adds two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            
            <returns>The sum of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[][],System.Double[][])">
            <summary>
              Adds two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            
            <returns>The sum of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[][],System.Double)">
            <summary>
              Adds a matrix and a scalar.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="x">A scalar.</param>
            
            <returns>The sum of the given matrix and scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Adds a vector to a column or row of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="vector">A vector.</param>
            <param name="dimension">
              Pass 0 if the vector should be added row-wise, 
              or 1 if the vector should be added column-wise.
            </param>
            
        </member>
        <member name="M:Accord.Math.Matrix.AddToDiagonal(System.Double[0:,0:],System.Double,System.Boolean)">
            <summary>
              Adds a scalar to the diagonal of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="scalar">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.AddToDiagonal(System.Double[][],System.Double,System.Boolean)">
            <summary>
              Adds a scalar to the diagonal of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="scalar">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.SubtractFromDiagonal(System.Double[][],System.Double,System.Boolean)">
            <summary>
              Subtracts a scalar from the diagonal of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="scalar">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.SubtractFromDiagonal(System.Double[0:,0:],System.Double,System.Boolean)">
            <summary>
              Subtracts a scalar from the diagonal of a matrix.
            </summary>
            
            <param name="matrix">A matrix.</param>
            <param name="scalar">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Adds a vector to a column or row of a matrix.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A vector.</param>
            <param name="dimension">The dimension to add the vector to.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[][],System.Double[],System.Int32)">
            <summary>
              Adds a vector to a column or row of a matrix.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A vector.</param>
            <param name="dimension">The dimension to add the vector to.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[],System.Double[])">
            <summary>
              Adds two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The addition of the given vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Add(System.Double[],System.Double)">
            <summary>
              Adds two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            
            <returns>The addition of the given vectors.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[0:,0:],System.Double[0:,0:],System.Boolean)">
            <summary>
              Subtracts two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original matrix; false to return a new matrix.</param>
            
            <returns>The subtraction of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[][],System.Double[][])">
            <summary>
              Subtracts two matrices.
            </summary>
            
            <param name="a">A matrix.</param>
            <param name="b">A matrix.</param>
            
            <returns>The subtraction of the given matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[0:,0:],System.Double)">
            <summary>
              Subtracts a scalar from each element of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double,System.Double[0:,0:])">
            <summary>
              Elementwise subtracts an element of a matrix from a scalar.
            </summary>
            
            <param name="x">A scalar.</param>
            <param name="matrix">A matrix.</param>
            
            <returns>The elementwise subtraction of scalar a and matrix b.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Int32,System.Double[0:,0:])">
            <summary>
              Elementwise subtracts an element of a matrix from a scalar.
            </summary>
            
            <param name="x">A scalar.</param>
            <param name="matrix">A matrix.</param>
            
            <returns>The elementwise subtraction of scalar a and matrix b.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[],System.Double[],System.Boolean)">
            <summary>
              Subtracts two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of vector b from vector a.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Int32[],System.Int32[],System.Boolean)">
            <summary>
              Subtracts two vectors.
            </summary>
            
            <param name="a">A vector.</param>
            <param name="b">A vector.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of vector b from vector a.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double[],System.Double,System.Boolean)">
            <summary>
              Subtracts a scalar from a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of given scalar from all elements in the given vector.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Int32[],System.Int32,System.Boolean)">
            <summary>
              Subtracts a scalar from a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            <param name="inPlace">True to perform the operation in-place,
            overwriting the original array; false to return a new array.</param>
            
            <returns>The subtraction of given scalar from all elements in the given vector.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Subtract(System.Double,System.Double[])">
            <summary>
              Subtracts a scalar from a vector.
            </summary>
            
            <param name="vector">A vector.</param>
            <param name="x">A scalar.</param>
            
            <returns>The subtraction of the given vector elements from the given scalar.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Power(System.Double[0:,0:],System.Int32)">
            <summary>
              Multiplies a matrix by itself <c>n</c> times.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[0:,0:])">
            <summary>
              Returns a <see cref="T:System.String"/> represents a matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[0:,0:],System.Boolean,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="multiline">
              If set to <c>true</c>, the matrix will be written using multiple
              lines. If set to <c>false</c>, the matrix will be written in a 
              single line.</param>
              
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[0:,0:],Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[0:,0:],System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[0:,0:],System.String)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[][])">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[][],Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[][],System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            <param name="matrix">The matrix.</param>
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[][],System.String)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents a matrix.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>, <see cref="T:Accord.Math.CSharpArrayFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/>, or <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> 
              for more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[])">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="array">The array.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> or <see cref="T:Accord.Math.DefaultArrayFormatProvider"/>
              for examples and more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[],Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="array">The array.</param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> or <see cref="T:Accord.Math.DefaultArrayFormatProvider"/>
              for examples and more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[],System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="matrix">The matrix.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <param name="provider">
              The <see cref="T:Accord.Math.IMatrixFormatProvider"/> to be used
              when creating the resulting string. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> or <see cref="T:Accord.Math.DefaultArrayFormatProvider"/>
              for examples and more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.ToString(System.Double[],System.String)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents an array.
            </summary>
            
            <param name="array">The array.</param>
            
            <param name="format">
              The format to use when creating the resulting string.
            </param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
            <example>
              Please see <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/>,
              <see cref="T:Accord.Math.OctaveArrayFormatProvider"/> or <see cref="T:Accord.Math.DefaultArrayFormatProvider"/>
              for examples and more details.
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Parse(System.String)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
            </summary>
            <param name="str">The string representation of the matrix.</param>
            <returns>A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Parse(System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
            </summary>
            <param name="str">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <returns>A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ParseJagged(System.String,Accord.Math.IMatrixFormatProvider)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
            </summary>
            <param name="s">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <returns>A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.TryParse(System.String,Accord.Math.IMatrixFormatProvider,System.Double[0:,0:]@)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
              A return value indicates whether the conversion succeeded or failed.
            </summary>
            <param name="s">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <param name="matrix">A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</param>
            <result>When this method returns, contains the double-precision floating-point
            number matrix equivalent to the <see param="s"/> parameter, if the conversion succeeded, 
            or null if the conversion failed. The conversion fails if the <see param="s"/> parameter
            is null, is not a matrix in a valid format, or contains elements which represent
            a number less than MinValue or greater than MaxValue. This parameter is passed
            uninitialized. </result>
            
        </member>
        <member name="M:Accord.Math.Matrix.TryParse(System.String,Accord.Math.IMatrixFormatProvider,System.Double[][]@)">
            <summary>
              Converts the string representation of a matrix to its
              double-precision floating-point number matrix equivalent.
              A return value indicates whether the conversion succeeded or failed.
            </summary>
            <param name="s">The string representation of the matrix.</param>
            <param name="provider">
              The format provider to use in the conversion. Default is to use
              <see cref="P:Accord.Math.DefaultMatrixFormatProvider.CurrentCulture"/>.
            </param>
            <param name="matrix">A double-precision floating-point number matrix parsed
            from the given string using the given format provider.</param>
            <result>When this method returns, contains the double-precision floating-point
            number matrix equivalent to the <see param="s"/> parameter, if the conversion succeeded, 
            or null if the conversion failed. The conversion fails if the <see param="s"/> parameter
            is null, is not a matrix in a valid format, or contains elements which represent
            a number less than MinValue or greater than MaxValue. This parameter is passed
            uninitialized. </result>
            
        </member>
        <member name="M:Accord.Math.Matrix.Solve(System.Double[0:,0:],System.Double[0:,0:],System.Boolean)">
            <summary>
              Returns the solution matrix if the matrix is square or the least squares solution otherwise.
            </summary>
            
            <param name="matrix">The matrix for the linear problem.</param>
            <param name="rightSide">The right side <c>b</c>.</param>
            <param name="leastSquares">True to produce a solution even if the 
              <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
            
            <remarks>
              Please note that this does not check if the matrix is non-singular
              before attempting to solve. If a least squares solution is desired
              in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
              parameter when calling this function.
            </remarks>
            
            <example>
            <code>
            // Create a matrix. Please note that this matrix
            // is singular (i.e. not invertible), so only a 
            // least squares solution would be feasible here.
            
            double[,] matrix = 
            {
                { 1, 2, 3 },
                { 4, 5, 6 },
                { 7, 8, 9 },
            };
            
            // Define a right side matrix b:
            double[,] rightSide = { {1}, {2}, {3} };
            
            // Solve the linear system Ax = b by finding x:
            double[,] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
            
            // The answer should be { {-1/18}, {2/18}, {5/18} }.
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Solve(System.Double[0:,0:],System.Double[],System.Boolean)">
            <summary>
              Returns the solution matrix if the matrix is square or the least squares solution otherwise.
            </summary>
            
            <param name="matrix">The matrix for the linear problem.</param>
            <param name="rightSide">The right side <c>b</c>.</param>
            <param name="leastSquares">True to produce a solution even if the 
              <paramref name="matrix"/> is singular; false otherwise. Default is false.</param>
            
            <remarks>
              Please note that this does not check if the matrix is non-singular
              before attempting to solve. If a least squares solution is desired
              in case the matrix is singular, pass true to the <paramref name="leastSquares"/>
              parameter when calling this function.
            </remarks>
            
            <example>
            <code>
            // Create a matrix. Please note that this matrix
            // is singular (i.e. not invertible), so only a 
            // least squares solution would be feasible here.
            
            double[,] matrix = 
            {
                { 1, 2, 3 },
                { 4, 5, 6 },
                { 7, 8, 9 },
            };
            
            // Define a right side vector b:
            double[] rightSide = { 1, 2, 3 };
            
            // Solve the linear system Ax = b by finding x:
            double[] x = Matrix.Solve(matrix, rightSide, leastSquares: true);
            
            // The answer should be { -1/18, 2/18, 5/18 }.
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Matrix.Inverse(System.Double[0:,0:])">
            <summary>
              Computes the inverse of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Inverse(System.Double[0:,0:],System.Boolean)">
            <summary>
              Computes the inverse of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.PseudoInverse(System.Double[0:,0:])">
            <summary>
              Computes the pseudo-inverse of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Remove``1(``0[0:,0:],System.Int32[],System.Int32[])">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="data">The matrix to return the submatrix from.</param>
            <param name="rowIndexes">Array of row indices. Pass null to select all indices.</param>
            <param name="columnIndexes">Array of column indices. Pass null to select all indices.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.GetColumn``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets a column vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.GetColumn``1(``0[][],System.Int32)">
            <summary>
              Gets a column vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.GetColumns``1(``0[][],System.Int32[])">
            <summary>
              Gets a column vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.GetRow``1(``0[][],System.Int32)">
            <summary>
              Gets a row vector from a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.GetRows``1(``0[][],System.Int32[])">
            <summary>
              Gets a row vector from a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.GetColumns``1(``0[0:,0:],System.Int32[])">
            <summary>
              Gets a column vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.SetColumn``1(``0[0:,0:],System.Int32,``0[])">
            <summary>
              Stores a column vector into the given column position of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.GetRow``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets a row vector from a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.SetRow``1(``0[0:,0:],System.Int32,``0[])">
            <summary>
              Stores a row vector into the given row position of the matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.RemoveColumn``1(``0[][],System.Int32)">
            <summary>
              Returns a new matrix without one of its columns.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.RemoveColumn``1(``0[0:,0:],System.Int32)">
            <summary>
              Returns a new matrix without one of its columns.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``1(``0[0:,0:],``0[])">
            <summary>
              Returns a new matrix with a given column vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``1(``0[][],``0[])">
            <summary>
              Returns a new matrix with a given column vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``1(``0[0:,0:],``0[])">
            <summary>
              Returns a new matrix with a given row vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``1(``0[][],``0[])">
            <summary>
              Returns a new matrix with a given row vector inserted at the end of the original matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``1(``0[0:,0:],``0[],System.Int32)">
            <summary>
              Returns a new matrix with a given column vector inserted at a given index.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertColumn``1(``0[][],``0[],System.Int32)">
            <summary>
              Returns a new matrix with a given column vector inserted at a given index.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``1(``0[0:,0:],``0[],System.Int32)">
            <summary>
              Returns a new matrix with a given row vector inserted at a given index.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.InsertRow``1(``0[][],``0[],System.Int32)">
            <summary>
              Returns a new matrix with a given row vector inserted at a given index.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.RemoveRow``1(``0[0:,0:],System.Int32)">
            <summary>
              Returns a new matrix without one of its rows.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.RemoveAt``1(``0[],System.Int32)">
            <summary>
              Removes an element from a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Count``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
              Gets the number of elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
        </member>
        <member name="M:Accord.Math.Matrix.First``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
              Gets the indices of the first element matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[],System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
            <param name="firstOnly">
               Set to true to stop when the first element is
               found, set to false to get all elements.
            </param>
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[0:,0:],System.Func{``0,System.Boolean})">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
        </member>
        <member name="M:Accord.Math.Matrix.Find``1(``0[0:,0:],System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
              Gets the indices of all elements matching a certain criteria.
            </summary>
            <typeparam name="T">The type of the array.</typeparam>
            <param name="data">The array to search inside.</param>
            <param name="func">The search criteria.</param>
            <param name="firstOnly">
               Set to true to stop when the first element is
               found, set to false to get all elements.
            </param>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(System.Nullable{``0}[],System.Int32@)">
            <summary>
              Gets the maximum non-null element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[],System.Int32@)">
            <summary>
              Gets the maximum element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[])">
            <summary>
              Gets the maximum element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[],System.Int32@)">
            <summary>
              Gets the minimum element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[])">
            <summary>
              Gets the minimum element in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[],System.Int32,System.Int32@)">
            <summary>
              Gets the maximum element in a vector up to a fixed length.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[],System.Int32)">
            <summary>
              Gets the maximum element in a vector up to a fixed length.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[],System.Int32,System.Int32@)">
            <summary>
              Gets the minimum element in a vector up to a fixed length.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[],System.Int32)">
            <summary>
              Gets the minimum element in a vector up to a fixed length.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:])">
            <summary>
              Gets the maximum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:],System.Tuple{System.Int32,System.Int32}@)">
            <summary>
              Gets the maximum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:])">
            <summary>
              Gets the minimum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:],System.Tuple{System.Int32,System.Int32}@)">
            <summary>
              Gets the minimum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[][])">
            <summary>
              Gets the maximum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[][],System.Tuple{System.Int32,System.Int32}@)">
            <summary>
              Gets the maximum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[][])">
            <summary>
              Gets the minimum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[][],System.Tuple{System.Int32,System.Int32}@)">
            <summary>
              Gets the minimum value of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets the maximum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[0:,0:],System.Int32,System.Int32[]@)">
            <summary>
              Gets the maximum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:],System.Int32)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[0:,0:],System.Int32,System.Int32[]@)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[][],System.Int32)">
            <summary>
              Gets the maximum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Max``1(``0[][],System.Int32,System.Int32[]@)">
            <summary>
              Gets the maximum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[][],System.Int32)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Min``1(``0[][],System.Int32,System.Int32[]@)">
            <summary>
              Gets the minimum values across one dimension of a matrix.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[])">
            <summary>
              Gets the range of the values in a vector.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Int32[])">
            <summary>
              Gets the range of the values in a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Int32[0:,0:])">
            <summary>
              Gets the range of the values across a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[0:,0:])">
            <summary>
              Gets the range of the values across a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[0:,0:],System.Int32)">
            <summary>
              Gets the range of the values across the columns of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Range(System.Double[][],System.Int32)">
            <summary>
              Gets the range of the values across the columns of a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Swap``1(``0[],System.Int32[])">
            <summary>
              Performs an in-place re-ordering of elements in 
              a given array using the given vector of indices.
            </summary>
            
            <param name="values">The values to be ordered.</param>
            <param name="indices">The new index positions.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Distinct``1(``0[0:,0:])">
            <summary>
              Retrieves a list of the distinct values for each matrix column.
            </summary>
            
            <param name="values">The matrix.</param>
            
            <returns>An array containing arrays of distinct values for
            each column in the <paramref name="values"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Distinct``1(``0[][])">
            <summary>
              Retrieves a list of the distinct values for each matrix column.
            </summary>
            
            <param name="values">The matrix.</param>
            
            <returns>An array containing arrays of distinct values for
            each column in the <paramref name="values"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Distinct``1(``0[])">
            <summary>
              Retrieves only distinct values contained in an array.
            </summary>
            
            <param name="values">The array.</param>
            
            <returns>An array containing only the distinct values in <paramref name="values"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Distinct``1(``0[],System.Boolean)">
            <summary>
              Retrieves only distinct values contained in an array.
            </summary>
            
            <param name="values">The array.</param>
            <param name="allowNulls">Whether to allow null values in 
              the method's output. Default is true.</param>
            
            <returns>An array containing only the distinct values in <paramref name="values"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Distinct``2(``0[],System.Func{``0,``1})">
            <summary>
              Retrieves only distinct values contained in an array.
            </summary>
            
            <param name="values">The array.</param>
            <param name="property">The property of the object used to determine distinct instances.</param>
            
            <returns>An array containing only the distinct values in <paramref name="values"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sort``2(``0[],``1[0:,0:],System.Collections.Generic.IComparer{``0})">
            <summary>
              Sorts the columns of a matrix by sorting keys.
            </summary>
            
            <param name="keys">The key value for each column.</param>
            <param name="values">The matrix to be sorted.</param>
            <param name="comparer">The comparer to use.</param>
            
        </member>
        <member name="M:Accord.Math.Matrix.Top``1(``0[],System.Int32,System.Boolean)">
            <summary>
              Retrieves the top <c>count</c> values of an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Bottom``1(``0[],System.Int32,System.Boolean)">
            <summary>
              Retrieves the bottom <c>count</c> values of an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Int32[])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Double[])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sign(System.Double[])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Double[0:,0:])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Abs(System.Int32[0:,0:])">
            <summary>
              Elementwise absolute value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sqrt(System.Double[])">
            <summary>
              Elementwise Square root.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Sqrt(System.Double[0:,0:])">
            <summary>
              Elementwise Square root.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Log(System.Double[0:,0:])">
            <summary>
              Elementwise Log operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Exp(System.Double[0:,0:])">
            <summary>
              Elementwise Exp operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Exp(System.Double[])">
            <summary>
              Elementwise Exp operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.Log(System.Double[])">
            <summary>
              Elementwise Log operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwisePower(System.Double[0:,0:],System.Double)">
            <summary>
              Elementwise power operation.
            </summary>
            
            <param name="x">A matrix.</param>
            <param name="y">A power.</param>
            
            <returns>Returns x elevated to the power of y.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwisePower(System.Double[],System.Double)">
            <summary>
              Elementwise power operation.
            </summary>
            
            <param name="x">A matrix.</param>
            <param name="y">A power.</param>
            
            <returns>Returns x elevated to the power of y.</returns>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[],System.Double[])">
            <summary>
              Elementwise divide operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Elementwise divide operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
              Elementwise divide operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[0:,0:],System.Double[],System.Int32,System.Boolean)">
            <summary>
              Elementwise division.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Double[][],System.Double[],System.Int32,System.Boolean)">
            <summary>
              Elementwise division.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseDivide(System.Int32[0:,0:],System.Int32[],System.Int32)">
            <summary>
              Elementwise division.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[],System.Double[])">
            <summary>
              Elementwise multiply operation.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[],System.Int32[])">
            <summary>
              Elementwise multiply operation.
            </summary>
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Elementwise multiply operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Int32[],System.Int32[])">
            <summary>
              Elementwise multiply operation.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Int32[0:,0:],System.Int32[0:,0:])">
            <summary>
              Elementwise multiplication.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Elementwise multiplication.
            </summary>
            
            <param name="a">The left matrix a.</param>
            <param name="b">The right vector b.</param>
            <param name="dimension">
              If set to 0, b will be multiplied with every row vector in a. 
              If set to 1, b will be multiplied with every column vector.
            </param>
            
        </member>
        <member name="M:Accord.Math.Matrix.ElementwiseMultiply(System.Double[0:,0:],System.Double[],System.Double[0:,0:],System.Int32)">
            <summary>
              Elementwise multiplication.
            </summary>
            
            <param name="a">The left matrix a.</param>
            <param name="b">The right vector b.</param>
            <param name="r">The result vector r.</param>
            <param name="dimension">
              If set to 0, b will be multiplied with every row vector in a. 
              If set to 1, b will be multiplied with every column vector.
            </param>
            
        </member>
        <member name="T:Accord.Math.Tools">
            <summary>
              Set of mathematical tools.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.SetupGenerator(System.Int32)">
            <summary>
              Sets a random seed for the internal number generator.
            </summary>
        </member>
        <member name="M:Accord.Math.Tools.Angle(System.Single,System.Single)">
            <summary>
              Gets the angle formed by the vector [x,y].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Angle(System.Double,System.Double)">
            <summary>
              Gets the angle formed by the vector [x,y].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Angle(AForge.IntPoint,AForge.IntPoint)">
            <summary>
              Gets the displacement angle between two points.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Direction(AForge.IntPoint,AForge.IntPoint)">
            <summary>
              Gets the displacement angle between two points, coded
              as an integer varying from 0 to 20.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.NextPowerOf2(System.Int32)">
            <summary>
              Returns the next power of 2 after the input value x.
            </summary>
            
            <param name="x">Input value x.</param>
            <returns>Returns the next power of 2 after the input value x.</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.PreviousPowerOf2(System.Int32)">
            <summary>
              Returns the previous power of 2 after the input value x.
            </summary>
            
            <param name="x">Input value x.</param>
            <returns>Returns the previous power of 2 after the input value x.</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Hypotenuse(System.Double,System.Double)">
            <summary>
              Hypotenuse calculus without overflow/underflow
            </summary>
            
            <param name="a">first value</param>
            <param name="b">second value</param>
            <returns>The hypotenuse Sqrt(a^2 + b^2)</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Hypotenuse(System.Decimal,System.Decimal)">
            <summary>
              Hypotenuse calculus without overflow/underflow
            </summary>
            
            <param name="a">first value</param>
            <param name="b">second value</param>
            <returns>The hypotenuse Sqrt(a^2 + b^2)</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Hypotenuse(System.Single,System.Single)">
            <summary>
              Hypotenuse calculus without overflow/underflow
            </summary>
            
            <param name="a">first value</param>
            <param name="b">second value</param>
            <returns>The hypotenuse Sqrt(a^2 + b^2)</returns>
            
        </member>
        <member name="M:Accord.Math.Tools.Mod(System.Int32,System.Int32)">
            <summary>
              Gets the proper modulus operation for
              an integer value x and modulo m.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Mod(System.Double,System.Double)">
            <summary>
              Gets the proper modulus operation for
              a real value x and modulo m.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.IntRange,AForge.IntRange,System.Int32)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.DoubleRange,AForge.DoubleRange,System.Double)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double,System.Double,System.Double[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Single,System.Single,System.Single,System.Single,System.Single[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double[])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double,System.Double,System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double[],System.Double[],System.Double,System.Double,System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double[],System.Double[],System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Double,System.Double,System.Double[][])">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Scale(AForge.IntRange,AForge.DoubleRange,System.Int32)">
            <summary>
              Converts the value x (which is measured in the scale
              'from') to another value measured in the scale 'to'.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Acosh(System.Double)">
            <summary>
              Returns the hyperbolic arc cosine of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Asinh(System.Double)">
            <summary>
            Returns the hyperbolic arc sine of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.Atanh(System.Double)">
            <summary>
            Returns the hyperbolic arc tangent of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.FactorialPower(System.Int32,System.Int32)">
            <summary>
              Returns the factorial falling power of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.TruncatedPower(System.Double,System.Double)">
            <summary>
              Truncated power function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.InvSqrt(System.Single)">
            <summary>
              Fast inverse floating-point square root.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.StableSort``1(``0[],System.Comparison{``0})">
            <summary>
              Sorts the elements of an entire one-dimensional array using the given comparison.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.StableSort``1(``0[])">
            <summary>
              Sorts the elements of an entire one-dimensional array using the given comparison.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Tools.StableSort``1(``0[],System.Int32[]@)">
            <summary>
              Sorts the elements of an entire one-dimensional array using the given comparison.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Tools.Random">
            <summary>
              Gets a reference to the random number generator used
              internally by the Accord.NET classes and methods.
            </summary>
        </member>
        <member name="T:Accord.Math.Special">
            <summary>
              Set of special mathematic functions.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  John D. Cook, http://www.johndcook.com/ </description></item>
              </list>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Special.Erfc(System.Double)">
            <summary>
              Complementary error function of the specified value.
            </summary>
            
            <remarks>
              http://mathworld.wolfram.com/Erfc.html
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Special.Erf(System.Double)">
            <summary>
              Error function of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Polevl(System.Double,System.Double[],System.Int32)">
            <summary>
              Evaluates polynomial of degree N
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.P1evl(System.Double,System.Double[],System.Int32)">
            <summary>
              Evaluates polynomial of degree N with assumption that coef[N] = 1.0
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.BSpline(System.Int32,System.Double)">
            <summary>
              Computes the Basic Spline of order <c>n</c>
            </summary>
        </member>
        <member name="M:Accord.Math.Special.Binomial(System.Int32,System.Int32)">
            <summary>
              Computes the binomial coefficients C(n,k).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Binomial(System.Double,System.Double)">
            <summary>
              Computes the binomial coefficients C(n,k).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogBinomial(System.Int32,System.Int32)">
            <summary>
              Computes the log binomial Coefficients Log[C(n,k)].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogBinomial(System.Double,System.Double)">
            <summary>
              Computes the log binomial Coefficients Log[C(n,k)].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Factorial(System.Double)">
            <summary>
              Returns the extended factorial definition of a real number.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogFactorial(System.Double)">
            <summary>
              Returns the log factorial of a number (ln(n!))
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogFactorial(System.Int32)">
            <summary>
              Returns the log factorial of a number (ln(n!))
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Factorial(System.Int32)">
            <summary>
              Computes the factorial of a number (n!)
            </summary>
        </member>
        <member name="M:Accord.Math.Special.Log1m(System.Double)">
            <summary>
              Computes log(1-x) without losing precision for small values of x.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.Log1p(System.Double)">
            <summary>
              Computes log(1+x) without losing precision for small values of x.
            </summary>
            
            <remarks>
              References:
              - http://www.johndcook.com/csharp_log_one_plus_x.html
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Special.Expm1(System.Double)">
            <summary>
              Compute exp(x) - 1 without loss of precision for small values of x.
            </summary>
            <remarks>
              References:
              - http://www.johndcook.com/cpp_expm1.html
            </remarks>
        </member>
        <member name="M:Accord.Math.Special.Epslon(System.Double)">
            <summary>
              Estimates unit round-off in quantities of size x.
            </summary>
            <remarks>
              This is a port of the epslon function from EISPACK.
            </remarks>
        </member>
        <member name="M:Accord.Math.Special.Sign(System.Double,System.Double)">
            <summary>
              Returns A with the sign of B.
            </summary>
            <remarks>
              This is a port of the sign transfer function from EISPACK.
            </remarks>
            <returns>If B > 0 then the result is ABS(A), else it is -ABS(A).</returns>
        </member>
        <member name="M:Accord.Math.Special.LogDiff(System.Double,System.Double)">
            <summary>
              Computes x + y without losing precision using ln(x) and ln(y).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogSum(System.Double,System.Double)">
            <summary>
              Computes x + y without losing precision using ln(x) and ln(y).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Special.LogSum(System.Single,System.Single)">
            <summary>
              Computes x + y without losing precision using ln(x) and ln(y).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.ConstraintType">
            <summary>
              Constraint type.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConstraintType.EqualTo">
            <summary>
              Equality constraint.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConstraintType.GreaterThanOrEqualTo">
            <summary>
              Inequality constraint specifying a greater than or equal to relationship.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConstraintType.LesserThanOrEqualTo">
            <summary>
              Inequality constraint specifying a lesser than or equal to relationship.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.LinearConstraint">
            <summary>
              Constraint with only linear terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(System.Int32)">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the constraint.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(System.Double[])">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="coefficients">The scalar coefficients specifying 
            how variables should be combined in the constraint.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.String)">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="function">The objective function to which
              this constraint refers to.</param>
            <param name="constraint">A <see cref="T:System.String"/> 
              specifying this constraint, such as "ax + b = c".</param>
            
            <remarks>
              The constraint string is always parsed using 
              <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>.
              This means numbers should be written using the English format, 
              using the dot (.) as the decimal separator.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Linq.Expressions.Expression{System.Func{System.Boolean}})">
            <summary>
              Constructs a new linear constraint.
            </summary>
            
            <param name="function">The objective function to which this 
              constraint refers to.</param>
            <param name="constraint">A <see cref="T:System.Linq.Expressions.Expression`1"/> specifying
              this constraint in the form of a lambda expression.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraint.TryParse(System.String,Accord.Math.Optimization.IObjectiveFunction,Accord.Math.Optimization.LinearConstraint@)">
            <summary>
              Attempts to create a <see cref="T:Accord.Math.Optimization.LinearConstraint"/>
              from a <see cref="T:System.String"/> representation.
            </summary>
            
            <param name="str">The string containing the constraint in textual form.</param>
            <param name="function">The objective function to which this constraint refers to.</param>
            <param name="constraint">The resulting constraint, if it could be parsed.</param>
            
            <returns><c>true</c> if the function could be parsed
              from the string, <c>false</c> otherwise.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.NumberOfVariables">
            <summary>
              Gets the number of variables in the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.VariablesAtIndices">
            <summary>
              Gets the index of the variables (in respective to the
              object function index) of the variables participating
              in this constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.CombinedAs">
            <summary>
              Gets the scalar coefficients combining the <see cref="P:Accord.Math.Optimization.LinearConstraint.VariablesAtIndices">
              variables</see> specified by the constraints.
            </summary>
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.ShouldBe">
            <summary>
              Gets the type of the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LinearConstraint.Value">
            <summary>
              Gets the value to be compared to the combined values
              of the variables.
            </summary>
            
        </member>
        <member name="T:Accord.Math.CSharpArrayFormatProvider">
            <summary>
              Gets the matrix representation used in C# multi-dimensional arrays.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              arrays and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from an array to a string representation:</para>
              
            <code>
              // Declare a number array
              double[] x = { 1, 2, 3, 4 };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(CSharpArrayFormatProvider.CurrentCulture);
              
              // the final result will be
              "double[] x = { 1, 2, 3, 4 }"
            </code>
            
            <para>
              Converting from strings to actual arrays:</para>
            
            <code>
              // Declare an input string
              string str = "double[] { 1, 2, 3, 4 }";
              
              // Convert the string representation to an actual number array:
              double[] array = Matrix.Parse(str, CSharpArrayFormatProvider.InvariantCulture);
              
              // array will now contain the actual number 
              // array representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.CSharpArrayFormatProvider.#ctor(System.IFormatProvider,System.Boolean,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpArrayFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpArrayFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.OctaveArrayFormatProvider">
            <summary>
              Format provider for the matrix format used by Octave.
            </summary>
            
            <example>
            <para>
              Converting from a multidimensional matrix to a 
              string representation:</para>
              
            <code>
              // Declare a number array
              double[,] x = 
              {
                 { 1, 2, 3, 4 },
                 { 5, 6, 7, 8 },
              };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(OctaveArrayFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              "[ 1, 2, 3, 4]"
            </code>
            
            <para>
              Converting from strings to actual matrices:</para>
            
            <code>
              // Declare an input string
              string str = "[ 1, 2, 3, 4]";
              
              // Convert the string representation to an actual number array:
              double[] array = Matrix.Parse(str, OctaveArrayFormatProvider.InvariantCulture);
              
              // array will now contain the actual number 
              // array representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.OctaveArrayFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.OctaveArrayFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.OctaveArrayFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.QrDecompositionD">
            <summary>
                 QR decomposition for a rectangular matrix.
            </summary>
            <remarks>
            <para>
              For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
              is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
              matrix <c>R</c> so that <c>A = Q * R</c>.</para>
            <para>
              The QR decomposition always exists, even if the matrix does not have
              full rank, so the constructor will never fail. The primary use of the
              QR decomposition is in the least squares solution of nonsquare systems
              of simultaneous linear equations.
              This will fail if <see cref="P:Accord.Math.Decompositions.QrDecompositionD.FullRank"/> returns <see langword="false"/>.</para>  
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Decompositions.ISolverMatrixDecomposition`1">
            <summary>
              Common interface for matrix decompositions which
              can be used to solve linear systems of equations.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverMatrixDecomposition`1.Solve(`0[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverMatrixDecomposition`1.Solve(`0[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.ISolverMatrixDecomposition`1.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.#ctor(System.Decimal[0:,0:])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Solve(System.Decimal[0:,0:])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.SolveTranspose(System.Decimal[0:,0:])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Solve(System.Decimal[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionD.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionD.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.LuDecomposition">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.LuDecomposition.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.#ctor(System.Double[0:,0:])">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Solve(System.Double[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.SolveTranspose(System.Double[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Solve(System.Double[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecomposition.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
              Please see remarks for important information regarding
              numerical stability when using this method.
            </summary>
            
            <remarks>
              Please keep in mind this is not one of the most reliable methods
              for checking singularity of a matrix. For a more reliable method,
              please use <see cref="M:Accord.Math.Matrix.IsSingular(System.Double[0:,0:])"/> or the 
              <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition"/>.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecomposition.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedLuDecompositionD">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.JaggedLuDecompositionD.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.#ctor(System.Decimal[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Solve(System.Decimal[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.SolveTranspose(System.Decimal[][])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Solve(System.Decimal[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionD.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionD.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.LeastSquaresFunction">
            <summary>
              Least Squares function delegate.
            </summary>
            
            <remarks>
              This delegate represents a parameterized function that, given a set of
              <paramref name="parameters"/> and an <paramref name="input"/> vector,
              produces an associated output value.
            </remarks>
            
            <param name="parameters">The function parameters, also known as weights or coefficients.</param>
            <param name="input">An input vector.</param>
            
            <returns>The output value produced given the <paramref name="input"/> vector
              using the given <paramref name="parameters"/>.</returns>
            
        </member>
        <member name="T:Accord.Math.Optimization.LeastSquaresGradientFunction">
            <summary>
              Gradient function delegate.
            </summary>
            
            <remarks>
              This delegate represents the gradient of a <see cref="T:Accord.Math.Optimization.LeastSquaresFunction">Least
              Squares objective function</see>. This function should compute the gradient vector
              in respect to the function <paramref name="parameters"/>.
            </remarks>
            
            <param name="parameters">The function parameters, also known as weights or coefficients.</param>
            <param name="input">An input vector.</param>
            <param name="result">The resulting gradient vector (w.r.t to the parameters).</param>
            
        </member>
        <member name="T:Accord.Math.Optimization.ILeastSquaresMethod">
            <summary>
              Common interface for Least Squares algorithms, i.e. algorithms
              that can be used to solve Least Squares optimization problems.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.ILeastSquaresMethod.Minimize(System.Double[][],System.Double[])">
            <summary>
              Attempts to find the best values for the parameter vector
              minimizing the discrepancy between the generated outputs
              and the expected outputs for a given set of input data.
            </summary>
            
            <param name="inputs">A set of input data.</param>
            <param name="outputs">The values associated with each 
              vector in the <paramref name="inputs"/> data.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.ILeastSquaresMethod.Function">
            <summary>
              Gets or sets a parameterized model function mapping input vectors
              into output values, whose optimum parameters must be found.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ILeastSquaresMethod.Gradient">
            <summary>
              Gets or sets a function that computes the gradient vector in respect
              to the function parameters, given a set of input and output values.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ILeastSquaresMethod.Parameters">
            <summary>
              Gets the number of variables (free parameters) in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ILeastSquaresMethod.Solution">
            <summary>
              Gets the solution found, the values of the parameters which
              optimizes the function, in a least squares sense.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ILeastSquaresMethod.StandardErrors">
            <summary>
              Gets standard error for each parameter in the solution.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.LineSearchFailedException">
            <summary>
              Line Search Failed Exception.
            </summary>
            
            <remarks>
              This exception may be thrown by the <see cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno">L-BFGS Optimizer</see>
              when the line search routine used by the optimization method fails.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.Int32,System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
            <param name="info">The error code information of the line search routine.</param>
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.String,System.Exception)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            
            <param name="message">Message providing some additional information.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LineSearchFailedException"/> class.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is null.
            </exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult"/> is zero (0).
            </exception>
            
        </member>
        <member name="M:Accord.Math.Optimization.LineSearchFailedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
              When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
            <exception cref="T:System.ArgumentNullException">
            The <paramref name="info"/> parameter is a null reference (Nothing in Visual Basic).
            </exception>
            <PermissionSet>
            	<IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*"/>
            	<IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter"/>
            </PermissionSet>
            
        </member>
        <member name="P:Accord.Math.Optimization.LineSearchFailedException.Information">
            <summary>
              Gets the error code information returned by the line search routine.
            </summary>
            
            <value>The error code information returned by the line search routine.</value>
            
        </member>
        <member name="T:Accord.Math.Environments.OctaveEnvironment">
             <summary>
               Programming environment for Octave.
             </summary>
            
             <remarks>
             <para>
               This class implements a Domain Specific Language (DSL) for
               C# which is remarkably similar to Octave. Please take a loook
               on what is possible to do using this class in the examples
               section.</para>
               
             <para>
               To use this class, inherit from <see cref="T:Accord.Math.Environments.OctaveEnvironment"/>.
               After this step, all code written inside your child class will
               be able to use the syntax below:</para>
             </remarks>
             
             <example>
             <para>
               Using the <c>mat</c> and <c>ret</c> keywords, it is possible
               to replicate most of the Octave environment inside plain C#
               code. The example below demonstrates how to compute the 
               Singular Value Decomposition of a matrix, which in turn was
               generated using <see cref="M:Accord.Math.Matrix.Magic(System.Int32)"/>.</para>
               
             <code>
               // Declare local matrices
               mat u = _, s = _, v = _; 
               
               // Compute a new mat
               mat M = magic(3) * 5;
               
               // Compute the SVD
               ret [u, s, v] = svd(M);
               
               // Write the matrix
               string str = u;
               
               /*
                    0.577350269189626 -0.707106781186548     0.408248290463863 
               u =  0.577350269189626 -1.48007149071427E-16 -0.816496580927726 
                    0.577350269189626  0.707106781186548     0.408248290463863
               */
             </code>
             
             <para>
               It is also possible to ignore certain parameters by
               providing a wildcard in the return structure:</para>
               
             <code>
               // Declare local matrices
               mat u = _, v = _; 
               
               // Compute a new mat
               mat M = magic(3) * 5;
               
               // Compute the SVD
               ret [u, _, v] = svd(M); // the second argument is omitted
             </code>
             
             <para>
               Standard matrix operations are also supported: </para>
               
             <code>
               
               mat I = eye(3); // 3x3 identity matrix
               
               mat A = I * 2;  // matrix-scalar multiplication
               
               Console.WriteLine(A);
               //
               //        2 0 0
               //    A = 0 2 0
               //        0 0 2
               
               mat B = ones(3, 6); // 3x6 unit matrix
               
               Console.WriteLine(B);
               //
               //        1 1 1 1 1 1
               //    B = 1 1 1 1 1 1
               //        1 1 1 1 1 1
               
               mat C = new double[,]
               {
                   { 2, 2, 2, 2, 2, 2 },
                   { 2, 0, 0, 0, 0, 2 },
                   { 2, 2, 2, 2, 2, 2 },
               };
               
               mat D = A * B - C;
               
               Console.WriteLine(D);
               //
               //        0 0 0 0 0 0
               //    C = 0 2 2 2 2 0
               //        0 0 0 0 0 0
             </code>
             </example>
             
             <seealso cref="T:Accord.Math.Matrix"/>
            
        </member>
        <member name="F:Accord.Math.Environments.OctaveEnvironment.pi">
            <summary>Pi.</summary>
        </member>
        <member name="F:Accord.Math.Environments.OctaveEnvironment.eps">
            <summary>Machine epsilon.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eye(System.Int32)">
            <summary>Creates an identity matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.inv(System.Double[0:,0:])">
            <summary>Inverts a matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.pinv(System.Double[0:,0:])">
            <summary>Inverts a matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.ones(System.Int32)">
            <summary>Creates a unit matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.ones(System.Int32,System.Int32)">
            <summary>Creates a unit matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.zeros(System.Int32)">
            <summary>Creates a unit matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.zeros(System.Int32,System.Int32)">
            <summary>Creates a unit matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.rand(System.Int32,System.Int32)">
            <summary>Random vector.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.size(System.Double[0:,0:])">
            <summary>Size of a matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.rank(System.Double[0:,0:])">
            <summary>Rank of a matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sum(System.Double[0:,0:])">
            <summary>Matrix sum vector.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sum(System.Double[])">
            <summary>Sum of vector elements.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.prod(System.Double[])">
            <summary>Product of vector elements.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sum(System.Double[0:,0:],System.Int32)">
            <summary>Matrix sum vector.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.round(System.Double)">
            <summary>Rounding.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.ceil(System.Double)">
            <summary>Ceiling.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.floor(System.Double)">
            <summary>Flooring.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.round(System.Double[])">
            <summary>Rounding.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.ceil(System.Double[])">
            <summary>Ceiling.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.floor(System.Double[])">
            <summary>Flooring.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.round(System.Double[0:,0:])">
            <summary>Rounding.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.ceil(System.Double[0:,0:])">
            <summary>Ceiling.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.floor(System.Double[0:,0:])">
            <summary>Flooring.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sin(System.Double)">
            <summary>Sin.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.cos(System.Double)">
            <summary>Cos.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.exp(System.Double)">
            <summary>Exponential value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.abs(System.Double)">
            <summary>Absolute value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.log(System.Double)">
            <summary>Logarithm.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sin(System.Double[])">
            <summary>Sin.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.cos(System.Double[])">
            <summary>Cos.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.exp(System.Double[])">
            <summary>Exponential value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.abs(System.Double[])">
            <summary>Absolute value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.log(System.Double[])">
            <summary>Logarithm.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.sin(System.Double[0:,0:])">
            <summary>Sin.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.cos(System.Double[0:,0:])">
            <summary>Cos.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.exp(System.Double[0:,0:])">
            <summary>Exponential value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.abs(System.Double[0:,0:])">
            <summary>Absolute value.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.log(System.Double[0:,0:])">
            <summary>Logarithm.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.magic(System.Int32)">
            <summary>Creates a magic square matrix.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.svd(System.Double[0:,0:])">
            <summary>Singular value decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.qr(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>QR decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.qr(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[]@)">
            <summary>QR decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@,System.Double[]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.eig(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>Eigenvalue decomposition.</summary>
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.chol(System.Double[0:,0:])">
            <summary>Cholesky decomposition.</summary>
        </member>
        <member name="F:Accord.Math.Environments.OctaveEnvironment.ret">
            <summary>
              Return setter keyword.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Environments.OctaveEnvironment.UseOctaveDimensionIndexing">
            <summary>
              Whether to use octave indexing or not.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Environments.OctaveEnvironment._">
            <summary>
              Matrix placeholder.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.OctaveEnvironment.retm">
            <summary>
              Return definition operator.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Environments.OctaveEnvironment.retm.Item(Accord.Math.Environments.OctaveEnvironment.mat[])">
            <summary>
              Can be used to set output arguments
              to the output of another function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.OctaveEnvironment.mat">
            <summary>
              Matrix definition operator.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Environments.OctaveEnvironment.mat.matrix">
            <summary>
              Inner matrix object.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.#ctor(System.Double[0:,0:])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Environments.OctaveEnvironment.mat"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Multiply(Accord.Math.Environments.OctaveEnvironment.mat,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Multiplication operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Multiply(Accord.Math.Environments.OctaveEnvironment.mat,System.Double)">
            <summary>
              Multiplication operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Multiply(System.Double,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Multiplication operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Addition(Accord.Math.Environments.OctaveEnvironment.mat,System.Double)">
            <summary>
              Addition operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Addition(System.Double,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Addition operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Addition(Accord.Math.Environments.OctaveEnvironment.mat,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Addition operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Subtraction(Accord.Math.Environments.OctaveEnvironment.mat,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Subtraction operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Subtraction(Accord.Math.Environments.OctaveEnvironment.mat,System.Double)">
            <summary>
              Subtraction operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Subtraction(System.Double,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Subtraction operator
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Equality(Accord.Math.Environments.OctaveEnvironment.mat,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Equality operator.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Inequality(Accord.Math.Environments.OctaveEnvironment.mat,Accord.Math.Environments.OctaveEnvironment.mat)">
            <summary>
              Inequality operator.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Implicit(System.Double[0:,0:])~Accord.Math.Environments.OctaveEnvironment.mat">
            <summary>
              Implicit conversion from double[,].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Implicit(Accord.Math.Environments.OctaveEnvironment.mat)~System.Double[0:,0:]">
            <summary>
              Implicit conversion to double[,].
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Implicit(Accord.Math.Environments.OctaveEnvironment.mat)~System.String">
            <summary>
              Implicit conversion to string.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.op_Implicit(System.Collections.Generic.List{Accord.Math.Environments.OctaveEnvironment.mat})~Accord.Math.Environments.OctaveEnvironment.mat">
            <summary>
              Implicit conversion from list.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.OctaveEnvironment.mat.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Environments.OctaveEnvironment.mat.t">
            <summary>
              Transpose operator.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedCholeskyDecompositionD">
            <summary>
                   Cholesky Decomposition of a symmetric, positive definite matrix.
               </summary>
            <remarks>
              <para>
                   For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                   lower triangular matrix <c>L</c> so that <c>A = L * L'</c>. The presented algorithm
                   only checks the upper triangular part of the matrix given as parameter and assumes
                   it is symmetric. If the matrix is not positive definite, the constructor returns a 
                   partial decomposition and sets two internal variables that can be queried using the
                   <see cref="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.#ctor(System.Decimal[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new Cholesky Decomposition.
            </summary>
            
            <param name="value">
              The symmetric matrix, given in upper triangular form, to be decomposed.</param>
            <param name="robust">
              True to perform a square-root free LDLt decomposition, false otherwise.</param>
            <param name="inPlace">
              True to perform the decomposition in place, storing the factorization in the
              lower triangular part of the given matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[][],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[])">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Solve(System.Decimal[],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.InverseDiagonal(System.Boolean)">
            <summary>
              Computes the diagonal of the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.InverseDiagonal(System.Decimal[],System.Boolean)">
             <summary>
               Computes the diagonal of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             <param name="result">The array to hold the result of the 
                computation. Should be of same length as the diagonal
                of the original matrix.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.InverseTrace(System.Boolean)">
             <summary>
               Computes the trace of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.FromLeftTriangularMatrix(System.Decimal[][])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.PositiveDefinite">
            <summary>
              Returns <see langword="true"/> if the matrix is positive definite.
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.IsNotDefined">
            <summary>
              Gets a value indicating whether the LDLt factorization
              has been computed successfully or if it is undefined.
            </summary>
            
            <value>
                <c>true</c> if the factorization is not defined; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.LeftTriangularFactor">
            <summary>
              Returns the left (lower) triangular factor
              <c>L</c> so that <c>A = L * D * L'</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.DiagonalMatrix">
            <summary>
              Returns the block diagonal matrix of diagonal
              elements in a LDLt decomposition.
            </summary>        
              
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Diagonal">
            <summary>
              Returns the one-dimensional array of diagonal 
              elements in a LDLt decomposition.
            </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Determinant">
            <summary>
              Returns the determinant of
              the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.LogDeterminant">
            <summary>
              If the matrix is positive-definite, returns the
              log-determinant of the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecompositionD.Nonsingular">
            <summary>
              Gets a value indicating whether the decomposed
              matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="T:Accord.Math.GaborKernelKind">
            <summary>
              Gabor kernel types.
            </summary>
            
        </member>
        <member name="F:Accord.Math.GaborKernelKind.Real">
            <summary>
              Creates kernel based on the real part of the Gabor function.
            </summary>
            
        </member>
        <member name="F:Accord.Math.GaborKernelKind.Imaginary">
            <summary>
              Creates a kernel based on the imaginary part of the Gabor function.
            </summary>
            
        </member>
        <member name="F:Accord.Math.GaborKernelKind.Magnitude">
            <summary>
              Creates a kernel based on the Magnitude of the Gabor function.
            </summary>
            
        </member>
        <member name="F:Accord.Math.GaborKernelKind.SquaredMagnitude">
            <summary>
              Creates a kernel based on the Squared Magnitude of the Gabor function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Gabor">
            <summary>
              Gabor functions.
            </summary>
            
            <remarks>
              This class has been contributed by Diego Catalano, author of the Catalano 
              Framework, a native port of AForge.NET and Accord.NET for Java and Android.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Gabor.Function1D(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              1-D Gabor function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.Function2D(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              2-D Gabor function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.RealFunction2D(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Real part of the 2-D Gabor function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.ImaginaryFunction2D(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Imaginary part of the 2-D Gabor function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.Kernel2D(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Computes the 2-D Gabor kernel.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.Kernel2D(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
              Computes the 2-D Gabor kernel.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.Kernel2D(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
              Computes the 2-D Gabor kernel.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gabor.Kernel2D(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,Accord.Math.GaborKernelKind)">
            <summary>
              Computes the 2-D Gabor kernel.
            </summary>
            
        </member>
        <member name="T:Accord.Math.AbsoluteConvergence">
            <summary>
              Absolute convergence criteria.
            </summary>
            
            <remarks>
              This class can be used to track progress and convergence
              of methods which rely on the absolute change of a value.
            </remarks>
            
            <example>
            <code>
              // Create a new convergence criteria for a maximum of 10 iterations
              var criteria = new AbsoluteConvergence(iterations: 10, tolerance: 0.1);
            
              int progress = 1;
            
              do
              {
                  // Do some processing...
            
            
                  // Update current iteration information:
                  criteria.NewValue = 12345.6 / progress++;
            
              } while (!criteria.HasConverged);
            
              
              // The method will converge after reaching the 
              // maximum of 10 iterations with a final value
              // of 1371.73:
              
              int iterations = criteria.CurrentIteration; // 10
              double value = criteria.OldValue; // 1371.7333333
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.AbsoluteConvergence.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.AbsoluteConvergence"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.AbsoluteConvergence.#ctor(System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.AbsoluteConvergence"/> class.
            </summary>
            
            <param name="iterations">The maximum number of iterations which should be
              performed by the iterative algorithm. Setting to zero indicates there
              is no maximum number of iterations. Default is 0.</param>
            <param name="tolerance">The maximum change in the watched value
              after an iteration of the algorithm used to detect convergence.
              Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.AbsoluteConvergence.Clear">
            <summary>
              Clears this instance.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.Tolerance">
            <summary>
              Gets or sets the maximum change in the watched value
              after an iteration of the algorithm used to detect 
              convergence. Default is 0.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.Iterations">
            <summary>
              Gets or sets the maximum number of iterations
              performed by the iterative algorithm. Default 
              is 100.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.OldValue">
            <summary>
              Gets the watched value before the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.NewValue">
            <summary>
              Gets or sets the watched value after the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.CurrentIteration">
            <summary>
              Gets or sets the current iteration number.
            </summary>
            
        </member>
        <member name="P:Accord.Math.AbsoluteConvergence.HasConverged">
            <summary>
              Gets whether the algorithm has converged.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.OptimizationProgressEventArgs">
            <summary>
              Optimization progress event arguments.
            </summary>
        </member>
        <member name="M:Accord.Math.Optimization.OptimizationProgressEventArgs.#ctor(System.Int32,System.Int32,System.Double[],System.Double,System.Double[],System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.OptimizationProgressEventArgs"/> class.
            </summary>
            
            <param name="iteration">The current iteration of the optimization method.</param>
            <param name="evaluations">The number of function evaluations performed.</param>
            <param name="gradient">The current gradient of the function.</param>
            <param name="gnorm">The norm of the current gradient</param>
            <param name="xnorm">The norm of the current parameter vector.</param>
            <param name="solution">The current solution parameters.</param>
            <param name="value">The value of the function evaluated at the current solution.</param>
            <param name="stp">The current step size.</param>
            <param name="finished"><c>True</c> if the method is about to terminate, <c>false</c> otherwise.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Iteration">
            <summary>
              Gets the current iteration of the method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Evaluations">
            <summary>
              Gets the number of function evaluations performed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Gradient">
            <summary>
              Gets the current gradient of the function being optimized.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.GradientNorm">
            <summary>
              Gets the norm of the current <see cref="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Gradient"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Solution">
            <summary>
              Gets the current solution parameters for the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.SolutionNorm">
            <summary>
              Gets the norm of the current <see cref="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Value">
            <summary>
              Gets the value of the function to be optimized
              at the current proposed <see cref="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Step">
            <summary>
              Gets the current step size.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.OptimizationProgressEventArgs.Finished">
            <summary>
              Gets or sets a value indicating whether the
              optimization process is about to terminate.
            </summary>
            
            <value><c>true</c> if finished; otherwise, <c>false</c>.</value>
            
        </member>
        <member name="T:Accord.Math.Optimization.NonlinearObjectiveFunction">
            <summary>
              Quadratic objective function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.IObjectiveFunction">
            <summary>
              Common interface for specifying objective functions.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.Variables">
            <summary>
              Gets input variable's labels for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.Indices">
            <summary>
              Gets the index of each input variable in the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.NumberOfVariables">
            <summary>
              Gets the number of input variables for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.IObjectiveFunction.Function">
            <summary>
              Gets the objective function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearObjectiveFunction.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="numberOfVariables">The number of parameters in the <paramref name="function"/>.</param>
            <param name="function">A lambda expression defining the objective
              function.</param>
            <param name="gradient">A lambda expression defining the gradient
              of the <paramref name="function">objective function</paramref>.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearObjectiveFunction.#ctor(System.Linq.Expressions.Expression{System.Func{System.Double}},System.Linq.Expressions.Expression{System.Func{System.Double[]}})">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="function">A <see cref="T:System.Linq.Expressions.Expression`1"/> containing 
              the function in the form of a lambda expression.</param>
            <param name="gradient">A <see cref="T:System.Linq.Expressions.Expression`1"/> containing 
              the gradient of the <paramref name="function">objective function</paramref>.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Variables">
            <summary>
              Gets input variable's labels for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Indices">
            <summary>
              Gets the index of each input variable in the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Function">
            <summary>
              Gets the objective function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Gradient">
            <summary>
              Gets the gradient of the <see cref="P:Accord.Math.Optimization.NonlinearObjectiveFunction.Function">objective function</see>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearObjectiveFunction.NumberOfVariables">
            <summary>
              Gets the number of input variables for the function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.CSharpMatrixFormatProvider">
            <summary>
              Gets the matrix representation used in C# multi-dimensional arrays.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              matrices and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from a multidimensional matrix to a 
              string representation:</para>
              
            <code>
              // Declare a number array
              double[,] x = 
              {
                 { 1, 2, 3, 4 },
                 { 5, 6, 7, 8 },
              };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(CSharpMatrixFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              "double[,] x =      " +
              "{                  " +
              "   { 1, 2, 3, 4 }, " +
              "   { 5, 6, 7, 8 }, " +
              "}"
            </code>
            
            <para>
              Converting from strings to actual matrices:</para>
            
            <code>
              // Declare an input string
              string str = "double[,] x = " +
              "{                          " +
              "   { 1, 2, 3, 4 },         " +
              "   { 5, 6, 7, 8 },         " +
              "}";
              
              // Convert the string representation to an actual number array:
              double[,] matrix = Matrix.Parse(str, CSharpMatrixFormatProvider.InvariantCulture);
              
              // matrix will now contain the actual multidimensional 
              // matrix representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.CSharpMatrixFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.CSharpMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition">
            <summary>
              Determines the Generalized eigenvalues and eigenvectors of two real square matrices.
            </summary>
            <remarks>
              <para>
                A generalized eigenvalue problem is the problem of finding a vector <c>v</c> that
                obeys <c>A * v = λ * B * v</c> where <c>A</c> and <c>B</c> are matrices. If <c>v</c>
                obeys this equation, with some <c>λ</c>, then we call <c>v</c> the generalized eigenvector
                of <c>A</c> and <c>B</c>, and <c>λ</c> is called the generalized eigenvalue of <c>A</c>
                and <c>B</c> which corresponds to the generalized eigenvector <c>v</c>. The possible
                values of <c>λ</c>, must obey the identity <c>det(A - λ*B) = 0</c>.</para>
              <para>
                Part of this code has been adapted from the original EISPACK routines in Fortran.</para>
             
              <para>
                References:
                <list type="bullet">
                  <item><description>
                    <a href="http://en.wikipedia.org/wiki/Generalized_eigenvalue_problem#Generalized_eigenvalue_problem">
                    http://en.wikipedia.org/wiki/Generalized_eigenvalue_problem#Generalized_eigenvalue_problem</a>
                  </description></item>
                  <item><description>
                    <a href="http://www.netlib.org/eispack/">
                    http://www.netlib.org/eispack/</a>
                  </description></item>
                </list>
              </para>
            </remarks>
            
            <example>
            // Suppose we have the following 
            // matrices A and B shown below:
            
            double[,] A = 
            {
                { 1, 2, 3},
                { 8, 1, 4},
                { 3, 2, 3}
            };
            
             double[,] B = 
             {
                { 5, 1, 1},
                { 1, 5, 1},
                { 1, 1, 5}
            };
            
            // Now, suppose we would like to find values for λ 
            // that are solutions for the equation det(A - λB) = 0
            
            // For this, we can use a Generalized Eigendecomposition
            var gevd = new GeneralizedEigenvalueDecomposition(A, B);
            
            // Now, if A and B are Hermitian and B is positive
            // -definite, then the eigenvalues λ will be real:
            double[] lambda = gevd.RealEigenvalues;
            
            // Lets check if they are indeed a solution:
            for (int i = 0; i &lt; lambda.Length; i++)
            {
                // Compute the determinant equation show above
                double det = Matrix.Determinant(A.Subtract(lambda[i].Multiply(B))); // almost zero
            }
            </example>
            
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.#ctor(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Constructs a new generalized eigenvalue decomposition.</summary>
            <param name="a">The first matrix of the (A,B) matrix pencil.</param>
            <param name="b">The second matrix of the (A,B) matrix pencil.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzhes(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Boolean,System.Double[0:,0:])">
             <summary>
               Adaptation of the original Fortran QZHES routine from EISPACK.
             </summary>
             <remarks>
               This subroutine is the first step of the qz algorithm
               for solving generalized matrix eigenvalue problems,
               Siam J. Numer. anal. 10, 241-256(1973) by Moler and Stewart.
            
               This subroutine accepts a pair of real general matrices and
               reduces one of them to upper Hessenberg form and the other
               to upper triangular form using orthogonal transformations.
               it is usually followed by  qzit,  qzval  and, possibly,  qzvec.
               
               For the full documentation, please check the original function.
             </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzit(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Double,System.Boolean,System.Double[0:,0:],System.Int32@)">
            <summary>
              Adaptation of the original Fortran QZIT routine from EISPACK.
            </summary>
            <remarks>
              This subroutine is the second step of the qz algorithm
              for solving generalized matrix eigenvalue problems,
              Siam J. Numer. anal. 10, 241-256(1973) by Moler and Stewart,
              as modified in technical note nasa tn d-7305(1973) by ward.
              
              This subroutine accepts a pair of real matrices, one of them
              in upper Hessenberg form and the other in upper triangular form.
              it reduces the Hessenberg matrix to quasi-triangular form using
              orthogonal transformations while maintaining the triangular form
              of the other matrix.  it is usually preceded by  qzhes  and
              followed by  qzval  and, possibly,  qzvec.
              
              For the full documentation, please check the original function.
            </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzval(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Double[],System.Double[],System.Double[],System.Boolean,System.Double[0:,0:])">
            <summary>
              Adaptation of the original Fortran QZVAL routine from EISPACK.
            </summary>
            <remarks>
              This subroutine is the third step of the qz algorithm
              for solving generalized matrix eigenvalue problems,
              Siam J. Numer. anal. 10, 241-256(1973) by Moler and Stewart.
              
              This subroutine accepts a pair of real matrices, one of them
              in quasi-triangular form and the other in upper triangular form.
              it reduces the quasi-triangular matrix further, so that any
              remaining 2-by-2 blocks correspond to pairs of complex
              Eigenvalues, and returns quantities whose ratios give the
              generalized eigenvalues.  it is usually preceded by  qzhes
              and  qzit  and may be followed by  qzvec.
              
              For the full documentation, please check the original function.
            </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.qzvec(System.Int32,System.Double[0:,0:],System.Double[0:,0:],System.Double[],System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
              Adaptation of the original Fortran QZVEC routine from EISPACK.
            </summary>
            <remarks>
              This subroutine is the optional fourth step of the qz algorithm
              for solving generalized matrix eigenvalue problems,
              Siam J. Numer. anal. 10, 241-256(1973) by Moler and Stewart.
              
              This subroutine accepts a pair of real matrices, one of them in
              quasi-triangular form (in which each 2-by-2 block corresponds to
              a pair of complex eigenvalues) and the other in upper triangular
              form.  It computes the eigenvectors of the triangular problem and
              transforms the results back to the original coordinate system.
              it is usually preceded by  qzhes,  qzit, and  qzval.
              
              For the full documentation, please check the original function.
            </remarks>
        </member>
        <member name="M:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.RealAlphas">
            <summary>Returns the real parts of the alpha values.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.ImaginaryAlphas">
            <summary>Returns the imaginary parts of the alpha values.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.Betas">
            <summary>Returns the beta values.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.IsSingular">
            <summary>
              Returns true if matrix B is singular.
            </summary>
            <remarks>
              This method checks if any of the generated betas is zero. It
              does not says that the problem is singular, but only that one
              of the matrices of the pencil (A,B) is singular.
            </remarks>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.IsDegenerate">
            <summary>
              Returns true if the eigenvalue problem is degenerate (ill-posed).
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
            <remarks>
              The eigenvalues are computed using the ratio alpha[i]/beta[i],
              which can lead to valid, but infinite eigenvalues.
            </remarks>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>	
            <remarks>
              The eigenvalues are computed using the ratio alpha[i]/beta[i],
              which can lead to valid, but infinite eigenvalues.
            </remarks>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.GeneralizedEigenvalueDecomposition.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.CholeskyDecompositionF">
            <summary>
                Cholesky Decomposition of a symmetric, positive definite matrix.
            </summary>
            <remarks>
              <para>
                For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                lower triangular matrix <c>L</c> so that <c>A = L * L'</c>.
                If the matrix is not symmetric or positive definite, the constructor returns a partial 
                decomposition and sets two internal variables that can be queried using the
                <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionF.Symmetric"/> and <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionF.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            <param name="value">The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square root free LDLt decomposition,
            false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square-root free LDLt decomposition,
            false otherwise.</param>
            <param name="lowerTriangular">True to assume the <paramref name="value">value
            matrix</paramref> is a lower triangular symmetric matrix, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[0:,0:])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is not symmetric and positive definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[0:,0:],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Solve(System.Single[],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * x = b</c>.</summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Inverse">
            <summary>
              Computes the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.FromLeftTriangularMatrix(System.Single[0:,0:])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Symmetric">
             <summary>
               Returns <see langword="true"/> if the matrix is symmetric.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.PositiveDefinite">
             <summary>
               Returns <see langword="true"/> if the matrix is positive definite.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.LeftTriangularFactor">
             <summary>
               Returns the left (lower) triangular factor <c>L</c> so that <c>A = L * D * L'</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.DiagonalMatrix">
             <summary>
               Returns the block diagonal matrix of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Diagonal">
             <summary>
               Returns the one-dimensional array of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Determinant">
             <summary>
               Returns the determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.LogDeterminant">
             <summary>
               Returns the log-determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionF.Nonsingular">
             <summary>
               Returns if the matrix is non-singular (i.e. invertible).
             </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.BinarySearch">
            <summary>
              Binary search root finding algorithm.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.BinarySearch.#ctor(System.Func{System.Int32,System.Double},System.Int32,System.Int32)">
            <summary>
              Constructs a new Binary search algorithm.
            </summary>
            
            <param name="function">The function to be searched.</param>
            <param name="a">Start of search region.</param>
            <param name="b">End of search region.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BinarySearch.Find(System.Double)">
            <summary>
              Attempts to find a root in the interval [a;b] 
            </summary>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BinarySearch.FindRoot">
            <summary>
              Attempts to find a root in the interval [a;b] 
            </summary>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BinarySearch.Find(System.Func{System.Int32,System.Double},System.Int32,System.Int32,System.Double)">
            <summary>
              Finds a value of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to have its root computed.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="value">The value to be looked for in the function.</param>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.BinarySearch.LowerBound">
            <summary>
              Gets or sets the lower bound for the search interval <c>a</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BinarySearch.UpperBound">
            <summary>
              Gets or sets the lower bound for the search interval <c>a</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BinarySearch.Solution">
            <summary>
              Gets the solution found in the last call
              to or <see cref="M:Accord.Math.Optimization.BinarySearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BinarySearch.Value">
            <summary>
              Gets the value at the solution found in the last call
              to <see cref="M:Accord.Math.Optimization.BinarySearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BinarySearch.Function">
            <summary>
              Gets the function to be searched.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.SingularValueDecompositionF">
             <summary>
               Singular Value Decomposition for a rectangular matrix.
             </summary>
            
             <remarks>
              <para>
                  For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the singular value decomposition
               is an m-by-n orthogonal matrix <c>U</c>, an n-by-n diagonal matrix <c>S</c>, and
               an n-by-n orthogonal matrix <c>V</c> so that <c>A = U * S * V'</c>.
               The singular values, <c>sigma[k] = S[k,k]</c>, are ordered so that
               <c>sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1]</c>.</para>
              <para>
               The singular value decomposition always exists, so the constructor will
               never fail. The matrix condition number and the effective numerical
               rank can be computed from this decomposition.</para>
              <para>
               WARNING! Please be aware that if A has less rows than columns, it is better
               to compute the decomposition on the transpose of A and then swap the left
               and right eigenvectors. If the routine is computed on A directly, the diagonal
               of singular values may contain one or more zeros. The identity A = U * S * V'
               may still hold, however. To overcome this problem, pass true to the
               <see cref="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean,System.Boolean)">autoTranspose</see> argument of the class constructor.</para>
              <para>
               This routine computes the economy decomposition of A.</para> 
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:])">
             <summary>
               Constructs a new singular value decomposition.
             </summary>
            
             <param name="value">
               The matrix to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>
                Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Solve(System.Single[0:,0:])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.SolveForDiagonal(System.Single[])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a linear equation system of the form Ax = b.
            </summary>
            <param name="value">The b from the equation Ax = b.</param>
            <returns>The x from equation Ax = b.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Inverse">
             <summary>
               Computes the (pseudo-)inverse of the matrix given to the Singular value decomposition.
             </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecompositionF.Clone">
             <summary>
               Creates a new object that is a copy of the current instance.
             </summary>
             <returns>
               A new object that is a copy of this instance.
             </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Condition">
             <summary>
               Returns the condition number <c>max(S) / min(S)</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Threshold">
             <summary>
               Returns the singularity threshold.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.TwoNorm">
             <summary>
               Returns the Two norm.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Rank">
             <summary>
               Returns the effective numerical matrix rank.
             </summary>
            
             <value>Number of non-negligible singular values.</value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.IsSingular">
             <summary>
               Gets whether the decomposed matrix is singular.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Diagonal">
             <summary>
               Gets the one-dimensional array of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.DiagonalMatrix">
             <summary>
              Returns the block diagonal matrix of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.RightSingularVectors">
             <summary>
               Returns the V matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.LeftSingularVectors">
             <summary>
               Returns the U matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.Ordering">
             <summary>
               Returns the ordering in which the singular values have been sorted.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.AbsoluteDeterminant">
             <summary>
               Returns the absolute value of the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.LogDeterminant">
             <summary>
               Returns the log of the absolute value for the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.PseudoDeterminant">
             <summary>
               Returns the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecompositionF.LogPseudoDeterminant">
             <summary>
               Returns the log of the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.EigenvalueDecompositionF">
            <summary>
                Determines the Eigenvalues and eigenvectors of a real square matrix.
            </summary>
            <remarks>
              <para>
                In the mathematical discipline of linear algebra, Eigendecomposition
                or sometimes spectral decomposition is the factorization of a matrix
                into a canonical form, whereby the matrix is represented in terms of
                its Eigenvalues and eigenvectors.</para>
              <para>
                If <c>A</c> is symmetric, then <c>A = V * D * V'</c> and <c>A = V * V'</c>
                where the eigenvalue matrix <c>D</c> is diagonal and the eigenvector matrix <c>V</c> is orthogonal.
                If <c>A</c> is not symmetric, the eigenvalue matrix <c>D</c> is block diagonal
                with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
                <c>lambda + i*mu</c>, in 2-by-2 blocks, <c>[lambda, mu; -mu, lambda]</c>.
                The columns of <c>V</c> represent the eigenvectors in the sense that <c>A * V = V * D</c>.
                The matrix V may be badly conditioned, or even singular, so the validity of the equation
                <c>A = V * D * inverse(V)</c> depends upon the condition of <c>V</c>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory consumption.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>    
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecompositionF.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Optimization.LevenbergMarquardt">
            <summary>
              Levenberg-Marquardt algorithm for solving Least-Squares problems.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LevenbergMarquardt.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LevenbergMarquardt"/> class.
            </summary>
            
            <param name="parameters">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LevenbergMarquardt.Minimize(System.Double[][],System.Double[])">
            <summary>
              Attempts to find the best values for the parameter vector
              minimizing the discrepancy between the generated outputs
              and the expected outputs for a given set of input data.
            </summary>
            
            <param name="inputs">A set of input data.</param>
            <param name="outputs">The values associated with each 
              vector in the <paramref name="inputs"/> data.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.LevenbergMarquardt.ComputeError(System.Double[][],System.Double[])">
            <summary>
              Compute model error for a given data set.
            </summary>
            
            <param name="input">The input points.</param>
            <param name="output">The output points.</param>
            
            <returns>The sum of squared errors for the data.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Function">
            <summary>
              Gets or sets a parameterized model function mapping input vectors
              into output values, whose optimum parameters must be found.
            </summary>
            
            <value>
              The function to be optimized.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Gradient">
            <summary>
              Gets or sets a function that computes the gradient vector in respect
              to the function parameters, given a set of input and output values.
            </summary>
            
            <value>
              The gradient function.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Solution">
            <summary>
              Gets the solution found, the values of the parameters which
              optimizes the function, in a least squares sense.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.LearningRate">
             <summary>
               Levenberg's damping factor, also known as lambda.
             </summary>
             
             <remarks><para>The value determines speed of learning.</para>
             
             <para>Default value is <b>0.1</b>.</para>
             </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Adjustment">
             <summary>
               Learning rate adjustment. 
             </summary>
             
             <remarks><para>The value by which the learning rate
             is adjusted when searching for the minimum cost surface.</para>
             
             <para>Default value is <b>10</b>.</para>
             </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Parameters">
            <summary>
              Gets the number of variables (free parameters) in the optimization problem.
            </summary>
            
            <value>
              The number of parameters.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Blocks">
            <summary>
              Gets or sets the number of blocks to divide the 
              Jacobian matrix in the Hessian calculation to
              preserve memory. Default is 1.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.Hessian">
            <summary>
              Gets the approximate Hessian matrix of second derivatives 
              generated in the last algorithm iteration. The Hessian is 
              stored in the upper triangular part of this matrix. See 
              remarks for details.
              </summary>
              
            <remarks>
            <para>
              The Hessian needs only be upper-triangular, since
              it is symmetric. The Cholesky decomposition will
              make use of this fact and use the lower-triangular
              portion to hold the decomposition, conserving memory</para>
              
            <para>
              Thus said, this property will hold the Hessian matrix
              in the upper-triangular part of this matrix, and store
              its Cholesky decomposition on its lower triangular part.</para>
              
            <para>
              Please note that this value is actually just an approximation to the
              actual Hessian matrix using the outer Jacobian approximation (H ~ J'J).
            </para>
            </remarks>
             
        </member>
        <member name="P:Accord.Math.Optimization.LevenbergMarquardt.StandardErrors">
            <summary>
              Gets standard error for each parameter in the solution.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergMatrix">
            <summary>
              Denavit Hartenberg matrix (commonly referred as T).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergMatrix.Compute(Accord.Math.Kinematics.DenavitHartenbergParameters)">
            <summary>
              Executes the transform calculations (T = Z*X).
            </summary>
            
            <returns>Transform matrix T.</returns>
            
            <remarks>Calling this method also updates the Transform property.</remarks>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergMatrix.Transform">
            <summary>
              Gets or sets the transformation matrix T (as in T = Z * X).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergMatrix.X">
            <summary>
              Gets or sets the matrix regarding X axis transformations.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergMatrix.Z">
            <summary>
              Gets or sets the matrix regarding Z axis transformations.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Constants">
            <summary>
              Common mathematical constants.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  http://www.johndcook.com/cpp_expm1.html </description></item>
              </list>
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Constants.EulerGamma">
            <summary>Euler-Mascheroni constant.</summary>
        </member>
        <member name="F:Accord.Math.Constants.DoubleEpsilon">
            <summary>Double-precision machine round-off error.</summary>
            <remarks>This value is actually different from Double.Epsilon.</remarks>
        </member>
        <member name="F:Accord.Math.Constants.SingleEpsilon">
            <summary>Single-precision machine round-off error.</summary>
            <remarks>This value is actually different from Single.Epsilon.</remarks>
        </member>
        <member name="F:Accord.Math.Constants.DoubleSmall">
            <summary>Double-precision small value.</summary>
        </member>
        <member name="F:Accord.Math.Constants.SingleSmall">
            <summary>Single-precision small value.</summary>
        </member>
        <member name="F:Accord.Math.Constants.LogMax">
            <summary>Maximum log on the machine.</summary>
        </member>
        <member name="F:Accord.Math.Constants.LogMin">
            <summary>Minimum log on the machine.</summary>
        </member>
        <member name="F:Accord.Math.Constants.LogPI">
            <summary>Log of number pi: log(pi).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Log2">
            <summary>Log of two: log(2).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Log3">
            <summary>Log of three: log(3).</summary>
        </member>
        <member name="F:Accord.Math.Constants.LogSqrt2PI">
            <summary>Log of square root of twice number pi: log(sqrt(2*π).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Log2PI">
            <summary>Log of twice number pi: log(2*pi).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Sqrt2PI">
            <summary>Square root of twice number pi: sqrt(2*π).</summary>
        </member>
        <member name="F:Accord.Math.Constants.SqrtHalfPI">
            <summary>Square root of half number π: sqrt(π/2).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Sqrt2">
            <summary>Square root of 2: sqrt(2).</summary>
        </member>
        <member name="F:Accord.Math.Constants.Sqrt2H">
            <summary>Half square root of 2: sqrt(2)/2.</summary>
        </member>
        <member name="T:Accord.Math.Norm">
            <summary>
              Static class Norm. Defines a set of extension methods defining norms measures.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Norm1(System.Double[0:,0:])">
            <summary>
              Returns the maximum column sum of the given matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Norm2(System.Double[0:,0:])">
            <summary>
              Returns the maximum singular value of the given matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Frobenius(System.Double[0:,0:])">
            <summary>
              Gets the square root of the sum of squares for all elements in a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Single[])">
            <summary>
              Gets the Squared Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[])">
            <summary>
              Gets the Squared Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Single[])">
            <summary>
              Gets the Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Double[])">
            <summary>
              Gets the Euclidean norm for a vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[0:,0:])">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Double[0:,0:],System.Int32)">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Double[0:,0:])">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Double[0:,0:],System.Int32)">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.SquareEuclidean(System.Single[0:,0:],System.Int32)">
            <summary>
              Gets the Squared Euclidean norm vector for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Single[0:,0:])">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Norm.Euclidean(System.Single[0:,0:],System.Int32)">
            <summary>
              Gets the Euclidean norm for a matrix.
            </summary>
            
        </member>
        <member name="T:Accord.Math.CSharpJaggedMatrixFormatProvider">
            <summary>
              Gets the matrix representation used in C# jagged arrays.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              arrays and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from a jagged matrix to a string representation:</para>
              
            <code>
              // Declare a number array
              double[][] x = 
              {
                 new double[] { 1, 2, 3, 4 },
                 new double[] { 5, 6, 7, 8 },
              };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(CSharpJaggedMatrixFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              "double[][] x =                  " +
              "{                               " +
              "   new double[] { 1, 2, 3, 4 }, " +
              "   new double[] { 5, 6, 7, 8 }, " +
              "}"
            </code>
            
            <para>
              Converting from strings to actual arrays:</para>
            
            <code>
              // Declare an input string
              string str = "double[][] x =     " +
              "{                               " +
              "   new double[] { 1, 2, 3, 4 }, " +
              "   new double[] { 5, 6, 7, 8 }, " +
              "}";
              
              // Convert the string representation to an actual number array:
              double[][] array = Matrix.Parse(str, CSharpJaggedMatrixFormatProvider.InvariantCulture);
              
              // array will now contain the actual jagged 
              // array representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.CSharpJaggedMatrixFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpJaggedMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.CSharpJaggedMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedCholeskyDecomposition">
            <summary>
                   Cholesky Decomposition of a symmetric, positive definite matrix.
               </summary>
            <remarks>
              <para>
                   For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                   lower triangular matrix <c>L</c> so that <c>A = L * L'</c>. The presented algorithm
                   only checks the upper triangular part of the matrix given as parameter and assumes
                   it is symmetric. If the matrix is not positive definite, the constructor returns a 
                   partial decomposition and sets two internal variables that can be queried using the
                   <see cref="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new Cholesky Decomposition.
            </summary>
            
            <param name="value">
              The symmetric matrix, given in upper triangular form, to be decomposed.</param>
            <param name="robust">
              True to perform a square-root free LDLt decomposition, false otherwise.</param>
            <param name="inPlace">
              True to perform the decomposition in place, storing the factorization in the
              lower triangular part of the given matrix.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[][],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[])">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Solve(System.Double[],System.Boolean)">
            <summary>
              Solves a set of equation systems of type <c>A * x = b</c>.
            </summary>
            
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.InverseDiagonal(System.Boolean)">
            <summary>
              Computes the diagonal of the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.InverseDiagonal(System.Double[],System.Boolean)">
             <summary>
               Computes the diagonal of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             <param name="result">The array to hold the result of the 
                computation. Should be of same length as the diagonal
                of the original matrix.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.InverseTrace(System.Boolean)">
             <summary>
               Computes the trace of the inverse of the decomposed matrix.
             </summary>
            
             <param name="destroy">True to conserve memory by reusing the
                same space used to hold the decomposition, thus destroying
                it in the process. Pass false otherwise.</param>
             
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.FromLeftTriangularMatrix(System.Double[][])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.PositiveDefinite">
            <summary>
              Returns <see langword="true"/> if the matrix is positive definite.
            </summary>
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.IsNotDefined">
            <summary>
              Gets a value indicating whether the LDLt factorization
              has been computed successfully or if it is undefined.
            </summary>
            
            <value>
                <c>true</c> if the factorization is not defined; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.LeftTriangularFactor">
            <summary>
              Returns the left (lower) triangular factor
              <c>L</c> so that <c>A = L * D * L'</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.DiagonalMatrix">
            <summary>
              Returns the block diagonal matrix of diagonal
              elements in a LDLt decomposition.
            </summary>        
              
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Diagonal">
            <summary>
              Returns the one-dimensional array of diagonal 
              elements in a LDLt decomposition.
            </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Determinant">
            <summary>
              Returns the determinant of
              the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.LogDeterminant">
            <summary>
              If the matrix is positive-definite, returns the
              log-determinant of the decomposed matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedCholeskyDecomposition.Nonsingular">
            <summary>
              Gets a value indicating whether the decomposed
              matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.EigenvalueDecomposition">
            <summary>
                Determines the eigenvalues and eigenvectors of a real square matrix.
            </summary>
            <remarks>
              <para>
                In the mathematical discipline of linear algebra, Eigendecomposition
                or sometimes spectral decomposition is the factorization of a matrix
                into a canonical form, whereby the matrix is represented in terms of
                its eigenvalues and eigenvectors.</para>
              <para>
                If <c>A</c> is symmetric, then <c>A = V * D * V'</c> and <c>A = V * V'</c>
                where the eigenvalue matrix <c>D</c> is diagonal and the eigenvector matrix <c>V</c> is orthogonal.
                If <c>A</c> is not symmetric, the eigenvalue matrix <c>D</c> is block diagonal
                with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
                <c>lambda + i*mu</c>, in 2-by-2 blocks, <c>[lambda, mu; -mu, lambda]</c>.
                The columns of <c>V</c> represent the eigenvectors in the sense that <c>A * V = V * D</c>.
                The matrix V may be badly conditioned, or even singular, so the validity of the equation
                <c>A = V * D * inverse(V)</c> depends upon the condition of <c>V</c>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.#ctor(System.Double[0:,0:])">
            <summary>
              Construct an eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Construct an Eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Construct an Eigenvalue decomposition.</summary>
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="assumeSymmetric">
              Defines if the matrix should be assumed as being symmetric
              regardless if it is or not. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory consumption.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.EigenvalueDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>    
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.Eigenvectors">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.EigenvalueDecomposition.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.CholeskyDecompositionD">
            <summary>
                Cholesky Decomposition of a symmetric, positive definite matrix.
            </summary>
            <remarks>
              <para>
                For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                lower triangular matrix <c>L</c> so that <c>A = L * L'</c>.
                If the matrix is not symmetric or positive definite, the constructor returns a partial 
                decomposition and sets two internal variables that can be queried using the
                <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionD.Symmetric"/> and <see cref="P:Accord.Math.Decompositions.CholeskyDecompositionD.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.#ctor(System.Decimal[0:,0:])">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            <param name="value">The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square root free LDLt decomposition,
            false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square-root free LDLt decomposition,
            false otherwise.</param>
            <param name="lowerTriangular">True to assume the <paramref name="value">value
            matrix</paramref> is a lower triangular symmetric matrix, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[0:,0:])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is not symmetric and positive definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[0:,0:],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Solve(System.Decimal[],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * x = b</c>.</summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Inverse">
            <summary>
              Computes the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.FromLeftTriangularMatrix(System.Decimal[0:,0:])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecompositionD.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Symmetric">
             <summary>
               Returns <see langword="true"/> if the matrix is symmetric.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.PositiveDefinite">
             <summary>
               Returns <see langword="true"/> if the matrix is positive definite.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.LeftTriangularFactor">
             <summary>
               Returns the left (lower) triangular factor <c>L</c> so that <c>A = L * D * L'</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.DiagonalMatrix">
             <summary>
               Returns the block diagonal matrix of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Diagonal">
             <summary>
               Returns the one-dimensional array of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Determinant">
             <summary>
               Returns the determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.LogDeterminant">
             <summary>
               Returns the log-determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecompositionD.Nonsingular">
             <summary>
               Returns if the matrix is non-singular (i.e. invertible).
             </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.IGradientOptimizationMethod">
            <summary>
              Common interface for function optimization methods which depend on
              having both an objective function and a gradient function definition
              available.
            </summary>
            
            <seealso cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.ConjugateGradient"/>
            <seealso cref="T:Accord.Math.Optimization.ResilientBackpropagation"/>
            
        </member>
        <member name="T:Accord.Math.Optimization.IOptimizationMethod">
            <summary>
              Common interface for function optimization methods.
            </summary>
            
            <seealso cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno"/>
            <seealso cref="T:Accord.Math.Optimization.ConjugateGradient"/>
            <seealso cref="T:Accord.Math.Optimization.ResilientBackpropagation"/>
            <seealso cref="T:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver"/>
            
        </member>
        <member name="M:Accord.Math.Optimization.IOptimizationMethod.Minimize(System.Double[])">
            <summary>
              Optimizes the defined function. 
            </summary>
            
            <param name="values">The initial guess values for the parameters.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.IOptimizationMethod.Solution">
            <summary>
              Gets the solution found, the values of the parameters which
              optimizes the function.
            </summary>
        </member>
        <member name="P:Accord.Math.Optimization.IGradientOptimizationMethod.Function">
            <summary>
              Gets or sets the function to be optimized.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.IGradientOptimizationMethod.Gradient">
            <summary>
              Gets or sets a function returning the gradient
              vector of the function to be optimized for a
              given value of its free parameters.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.IGradientOptimizationMethod.Parameters">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergParameters">
            <summary>
               Denavit Hartenberg joint-description parameters.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergParameters.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergParameters"/> class.
            </summary>
            
            <param name="alpha">Angle (in radians) of the Z axis relative to the last joint.</param>
            <param name="theta">Angle (in radians) of the X axis relative to the last joint.</param>
            <param name="radius">Length or radius of the joint.</param>
            <param name="offset">Offset along Z axis relatively to the last joint.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergParameters.#ctor">
            <summary>
               Denavit Hartenberg parameters constructor
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergParameters.Alpha">
            <summary>
               Angle in radians about common normal, from 
               old <c>z</c> axis to the new <c>z</c> axis.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergParameters.Theta">
            <summary>
               Angle in radians about previous <c>z</c>, 
               from old <c>x</c> to the new <c>x</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergParameters.Radius">
            <summary>
               Length of the joint (also known as <c>a</c>).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergParameters.Offset">
            <summary>
               Offset along previous <c>z</c> to the common normal (also known as <c>d</c>).
            </summary>
            
        </member>
        <member name="T:Accord.Math.Wavelets.IWavelet">
            <summary>
              Common interface for wavelets algorithms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Forward(System.Double[])">
            <summary>
              1-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Forward(System.Double[0:,0:])">
            <summary>
              2-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Backward(System.Double[])">
            <summary>
              1-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.IWavelet.Backward(System.Double[0:,0:])">
            <summary>
              2-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Wavelets.Haar">
            <summary>
              Haar Wavelet Transform.
            </summary>
            
            <remarks>
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Musawir Ali, An Introduction to Wavelets and the Haar Transform.
                  Available on: http://www.cs.ucf.edu/~mali/haar/ </description></item>
              </list>
            </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.#ctor(System.Int32)">
            <summary>
              Constructs a new Haar Wavelet Transform.
            </summary>
            <param name="levels">The number of iterations for the 2D transform.</param>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Forward(System.Double[])">
            <summary>
              1-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Backward(System.Double[])">
            <summary>
              1-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Forward(System.Double[0:,0:])">
            <summary>
              2-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.Backward(System.Double[0:,0:])">
            <summary>
              2-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.FWT(System.Double[])">
            <summary>
              Discrete Haar Wavelet Transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.IWT(System.Double[])">
            <summary>
              Inverse Haar Wavelet Transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.FWT(System.Double[0:,0:],System.Int32)">
            <summary>
              Discrete Haar Wavelet 2D Transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.Haar.IWT(System.Double[0:,0:],System.Int32)">
            <summary>
              Inverse Haar Wavelet 2D Transform
            </summary>
            
        </member>
        <member name="T:Accord.Math.Gamma">
             <summary>
               Gamma Γ(x) functions.
             </summary>
              
             <remarks>
             <para>
               In mathematics, the gamma function (represented by the capital Greek 
               letter Γ) is an extension of the factorial function, with its argument
               shifted down by 1, to real and complex numbers. That is, if <c>n</c> is
               a positive integer:</para>
             <code>
               Γ(n) = (n-1)!</code>
             <para>
               The gamma function is defined for all complex numbers except the negative
               integers and zero. For complex numbers with a positive real part, it is 
               defined via an improper integral that converges:</para>
             <code>
                      ∞
               Γ(z) = ∫  t^(z-1)e^(-t) dt
                      0
             </code>     
             <para>
               This integral function is extended by analytic continuation to all 
               complex numbers except the non-positive integers (where the function 
               has simple poles), yielding the meromorphic function we call the gamma
               function.</para>
             <para>
               The gamma function is a component in various probability-distribution 
               functions, and as such it is applicable in the fields of probability 
               and statistics, as well as combinatorics.</para>
               
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   Wikipedia contributors, "Gamma function,". Wikipedia, The Free 
                   Encyclopedia. Available at: http://en.wikipedia.org/wiki/Gamma_function 
                   </description></item>
                 <item><description>
                   Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
               </list></para>
             </remarks>
             
             <example>
             <code>
               double x = 0.17;
               
               // Compute main Gamma function and variants
               double gamma = Gamma.Function(x); // 5.4511741801042106
               double gammap = Gamma.Function(x, p: 2); // -39.473585841300675
               double log = Gamma.Log(x);        // 1.6958310313607003
               double logp = Gamma.Log(x, p: 2); // 3.6756317353404273
               double stir = Gamma.Stirling(x);  // 24.040352622960743
               double psi = Gamma.Digamma(x);    // -6.2100942259248626
               double tri = Gamma.Trigamma(x);   // 35.915302055854525
            
               double a = 4.2;
               
               // Compute the incomplete regularized Gamma functions P and Q:
               double lower = Gamma.LowerIncomplete(a, x); // 0.000015685073063633753
               double upper = Gamma.UpperIncomplete(a, x); // 0.9999843149269364
             </code>
             </example>
             
        </member>
        <member name="F:Accord.Math.Gamma.GammaMax">
            <summary>Maximum gamma on the machine.</summary>
        </member>
        <member name="M:Accord.Math.Gamma.Function(System.Double)">
            <summary>
              Gamma function of the specified value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Multivariate(System.Double,System.Int32)">
            <summary>
              Multivariate Gamma function
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Digamma(System.Double)">
            <summary>
              Digamma function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Trigamma(System.Double)">
            <summary>
              Trigamma function.
            </summary>
            
            <remarks>
              This code has been adapted from the FORTRAN77 and subsequent
              C code by B. E. Schneider and John Burkardt. The code had been
              made public under the GNU LGPL license.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Gamma.Stirling(System.Double)">
            <summary>
              Gamma function as computed by Stirling's formula.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.UpperIncomplete(System.Double,System.Double)">
            <summary>
              Upper incomplete regularized Gamma function Q
              (a.k.a the incomplete complemented Gamma function)
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.LowerIncomplete(System.Double,System.Double)">
            <summary>
              Lower incomplete regularized gamma function P
              (a.k.a. the incomplete Gamma function).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Log(System.Double)">
            <summary>
              Natural logarithm of the gamma function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Log(System.Double,System.Int32)">
            <summary>
              Natural logarithm of the multivariate Gamma function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Gamma.Inverse(System.Double,System.Double)">
            <summary>
              Inverse of the <see cref="M:Accord.Math.Gamma.UpperIncomplete(System.Double,System.Double)">complemented 
              incomplete Gamma integral (UpperIncomplete)</see>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Differentiation.FiniteDifferences">
            <summary>
              Derivative approximation by finite differences.
            </summary>
            
            <remarks>
            <para>
              Numerical differentiation is a technique of numerical analysis to
              produce an estimate of the derivative of a mathematical function or
              function subroutine using values from the function and perhaps other
              knowledge about the function.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                Trent F. Guidry, Calculating derivatives of a function numerically. Available on:
                http://www.trentfguidry.net/post/2009/07/12/Calculate-derivatives-function-numerically.aspx
                </description></item>
                </list>
             </para>
            </remarks>
            
            <example>
            <code>
            // Create a simple function with two parameters: f(x,y) = x² + y
            Func &lt;double[], double> function = x => Math.Pow(x[0], 2) + x[1];
            
            // The gradient function should be g(x,y) = &lt;2x, 1>
            
            // Create a new finite differences calculator
            var calculator = new FiniteDifferences(2, function);
            
            // Evaluate the gradient function at the point (2, -1)
            double[] result = calculator.Compute(2, -1); // answer is (4, 1)
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Differentiation.FiniteDifferences"/> class.
            </summary>
            
            <param name="variables">The number of free parameters in the function.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.#ctor(System.Int32,System.Func{System.Double[],System.Double})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Differentiation.FiniteDifferences"/> class.
            </summary>
            
            <param name="variables">The number of free parameters in the function.</param>
            <param name="function">The function to be differentiated.</param>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.Compute(System.Double[])">
            <summary>
              Computes the gradient at the given point <c>x</c>.
            </summary>
            <param name="x">The point where to compute the gradient.</param>
            <returns>The gradient of the function evaluated at point <c>x</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.derivative(System.Double[],System.Int32,System.Double)">
            <summary>
              Computes the derivative at point <c>x_i</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Differentiation.FiniteDifferences.createInterpolationCoefficients(System.Int32)">
            <summary>
              Creates the interpolation coefficients.
            </summary>
            <param name="points">The number of points in the tableau.</param>
            
        </member>
        <member name="P:Accord.Math.Differentiation.FiniteDifferences.Function">
            <summary>
              Gets or sets the function to be differentiated.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Differentiation.FiniteDifferences.StepSize">
            <summary>
              Gets or sets the relative step size used to
              approximate the derivatives. Default is 1e-2.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Geometry.ConvexityDefect">
            <summary>
              Convexity defect.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.ConvexityDefect.#ctor(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.ConvexityDefect"/> class.
            </summary>
            
            <param name="point">The most distant point from the hull.</param>
            <param name="start">The starting index of the defect in the contour.</param>
            <param name="end">The ending index of the defect in the contour.</param>
            <param name="depth">The depth of the defect (highest distance from the hull to
            any of the contour points).</param>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.Start">
            <summary>
              Gets or sets the starting index of the defect in the contour.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.End">
            <summary>
              Gets or sets the ending index of the defect in the contour.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.Point">
            <summary>
              Gets or sets the most distant point from the hull characterizing the defect.
            </summary>
            
            <value>The point.</value>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexityDefect.Depth">
            <summary>
              Gets or sets the depth of the defect (highest distance
              from the hull to any of the points in the contour).
            </summary>
            
        </member>
        <member name="T:Accord.Math.SineTransform">
            <summary>
              Discrete Sine Transform
            </summary>
            
            <remarks>
            <para>
              In mathematics, the discrete sine transform (DST) is a Fourier-related transform
              similar to the discrete Fourier transform (DFT), but using a purely real matrix. It
              is equivalent to the imaginary parts of a DFT of roughly twice the length, operating
              on real data with odd symmetry (since the Fourier transform of a real and odd function
              is imaginary and odd), where in some variants the input and/or output data are shifted
              by half a sample.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia contributors, "Discrete sine transform," Wikipedia, The Free Encyclopedia,
                  available at: http://en.wikipedia.org/w/index.php?title=Discrete_sine_transform </description></item>
                <item><description>
                  K. R. Castleman, Digital Image Processing. Chapter 13, p.288.
                  Prentice. Hall, 1998.</description></item>
              </list></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.SineTransform.DST(System.Double[])">
            <summary>
              Forward Discrete Sine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.SineTransform.IDST(System.Double[])">
            <summary>
              Inverse Discrete Sine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.SineTransform.DST(System.Double[][])">
            <summary>
              Forward Discrete Sine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.SineTransform.IDST(System.Double[][])">
            <summary>
              Inverse Discrete Sine Transform.
            </summary>
            
        </member>
        <member name="T:Accord.Math.ISingleValueConvergence">
            <summary>
              Common interface for convergence detection algorithms that 
              depend solely on a single value (such as the iteration error).
            </summary>
            
        </member>
        <member name="M:Accord.Math.ISingleValueConvergence.Clear">
            <summary>
              Resets this instance, reverting all iteration statistics
              statistics (number of iterations, last error) back to zero.
            </summary>
            
        </member>
        <member name="P:Accord.Math.ISingleValueConvergence.Tolerance">
            <summary>
              Gets or sets the maximum relative change in the watched value
              after an iteration of the algorithm used to detect convergence.
            </summary>
            
        </member>
        <member name="P:Accord.Math.ISingleValueConvergence.Iterations">
            <summary>
              Gets or sets the maximum number of iterations
              performed by the iterative algorithm.
            </summary>
            
        </member>
        <member name="P:Accord.Math.ISingleValueConvergence.NewValue">
            <summary>
              Gets or sets the watched value after the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.ISingleValueConvergence.CurrentIteration">
            <summary>
              Gets or sets the current iteration number.
            </summary>
            
        </member>
        <member name="P:Accord.Math.ISingleValueConvergence.HasConverged">
            <summary>
              Gets whether the algorithm has converged.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.ComparerDirection">
            <summary>
              Directions for the General Comparer.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Comparers.ComparerDirection.Ascending">
            <summary>
              Sorting will be performed in ascending order.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Comparers.ComparerDirection.Descending">
            <summary>
              Sorting will be performed in descending order.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.GeneralComparer">
            <summary>
              General comparer which supports multiple 
              directions and comparison of absolute values.
            </summary>
            
            <example>
            <code>
              // Assume we have values to sort
              double[] values = { 0, -5, 3, 1, 8 };
              
              // We can create an ad-hoc sorting rule considering only absolute values
              Array.Sort(values, new GeneralComparer(ComparerDirection.Ascending, Math.Abs));
              
              // Result will be { 0, 1, 3, 5, 8 }.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Comparers.ElementComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.ArrayComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.GeneralComparer"/>
            <seealso cref="T:Accord.Math.Comparers.CustomComparer`1"/>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer.#ctor(Accord.Math.Comparers.ComparerDirection)">
            <summary>
              Constructs a new General Comparer.
            </summary>
            
            <param name="direction">The direction to compare.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer.#ctor(Accord.Math.Comparers.ComparerDirection,System.Boolean)">
            <summary>
              Constructs a new General Comparer.
            </summary>
            
            <param name="direction">The direction to compare.</param>
            <param name="useAbsoluteValues">True to compare absolute values, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer.#ctor(Accord.Math.Comparers.ComparerDirection,System.Func{System.Double,System.Double})">
            <summary>
              Constructs a new General Comparer.
            </summary>
            
            <param name="direction">The direction to compare.</param>
            <param name="map">The mapping function which will be applied to
              each vector element prior to any comparisons.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer.Compare(System.Double,System.Double)">
            <summary>
              Compares two objects and returns a value indicating whether one is less than,
               equal to, or greater than the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.GeneralComparer.Compare(System.Int32,System.Int32)">
            <summary>
              Compares two objects and returns a value indicating whether one is less than,
               equal to, or greater than the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
        </member>
        <member name="P:Accord.Math.Comparers.GeneralComparer.Direction">
            <summary>
              Gets or sets the sorting direction
              used by this comparer.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergJoint">
            <summary>
              Denavit-Hartenberg Model Joint.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergJoint.#ctor(Accord.Math.Kinematics.DenavitHartenbergParameters)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergJoint"/> class.
            </summary>
            
            <param name="parameters">The <see cref="T:Accord.Math.Kinematics.DenavitHartenbergParameters">
            parameters </see> to be used to create the joint.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergJoint.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergJoint"/> class.
            </summary>
            
            <param name="alpha">Angle in radians on the Z axis relatively to the last joint.</param>
            <param name="theta">Angle in radians on the X axis relatively to the last joint.</param>
            <param name="radius">Length or radius of the joint.</param>
            <param name="offset">Offset along Z axis relatively to the last joint.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergJoint.Compute(AForge.Math.Matrix4x4,AForge.Math.Vector4)">
            <summary>
              Updates the joint transformation matrix and position
              given a model transform matrix and reference position.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergJoint.Matrix">
            <summary>
              Gets or sets the current <see cref="T:Accord.Math.Kinematics.DenavitHartenbergMatrix"/> associated with this joint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergJoint.Position">
            <summary>
              Gets or sets the position of this joint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergJoint.Parameters">
            <summary>
              Gets or sets the parameters for this joint.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergJointCollection">
            <summary>
              Collection of Denavit Hartenberg Joints.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergJointCollection.Add(Accord.Math.Kinematics.DenavitHartenbergParameters)">
            <summary>
              Adds an object to the end of this <see cref="T:Accord.Math.Kinematics.DenavitHartenbergJointCollection"/>.
            </summary>
            
            <param name="parameters">The <see cref="T:Accord.Math.Kinematics.DenavitHartenbergParameters">
              parameters</see> specifying the joint to be added.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergJointCollection.Add(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Adds an object to the end of this <see cref="T:Accord.Math.Kinematics.DenavitHartenbergJointCollection"/>.
            </summary>
            
            <param name="alpha">Angle in radians on the Z axis relatively to the last joint.</param>
            <param name="theta">Angle in radians on the X axis relatively to the last joint.</param>
            <param name="radius">Length or radius of the joint.</param>
            <param name="offset">Offset along Z axis relatively to the last joint.</param>
            
        </member>
        <member name="T:Accord.Math.Combinatorics">
            <summary>
              Static class for combinatorics functions.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.TruthTable(System.Int32)">
             <summary>
               Generates all possible two symbol ordered
               permutations with repetitions allowed (a truth table).
             </summary>
             
             <param name="length">The length of the sequence to generate.</param>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.TruthTable(System.Int32,System.Int32)">
             <summary>
               Generates all possible ordered permutations
               with repetitions allowed (a truth table).
             </summary>
             
             <param name="symbols">The number of symbols.</param>
             <param name="length">The length of the sequence to generate.</param>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.Combinations``1(``0[],System.Int32)">
            <summary>
              Enumerates all possible value combinations
              of a given size for an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Combinatorics.Permutations``1(``0[])">
            <summary>
              Enumerates all possible value permutations for
              a given array.
            </summary>
            
        </member>
        <member name="T:Accord.Math.ComplexExtensions.ComplexMatrix">
            <summary>
             Static class ComplexMatrix. Defines a set of extension methods
             that operates mainly on multidimensional arrays and vectors of
             AForge.NET's <seealso cref="T:AForge.Math.Complex"/> data type.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Abs(AForge.Math.Complex[])">
            <summary>
              Computes the absolute value of an array of complex numbers.
            </summary>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Sum(AForge.Math.Complex[])">
            <summary>
              Computes the sum of an array of complex numbers.
            </summary>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Multiply(AForge.Math.Complex[],AForge.Math.Complex[])">
            <summary>
              Elementwise multiplication of two complex vectors.
            </summary>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Magnitude(AForge.Math.Complex[])">
            <summary>
              Gets the magnitude of every complex number in an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Magnitude(AForge.Math.Complex[0:,0:])">
            <summary>
              Gets the magnitude of every complex number in a matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Phase(AForge.Math.Complex[])">
            <summary>
              Gets the phase of every complex number in an array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Re(AForge.Math.Complex[])">
            <summary>
              Returns the real vector part of the complex vector c.
            </summary>
            
            <param name="c">A vector of complex numbers.</param>
            
            <returns>A vector of scalars with the real part of the complex numbers.</returns>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Im(AForge.Math.Complex[])">
            <summary>
              Returns the imaginary vector part of the complex vector c.
            </summary>
            
            <param name="c">A vector of complex numbers.</param>
            
            <returns>A vector of scalars with the imaginary part of the complex numbers.</returns>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.ToArray(AForge.Math.Complex[])">
            <summary>
              Converts a complex number to a matrix of scalar values
              in which the first column contains the real values and 
              the second column contains the imaginary values.
            </summary>
            <param name="c">An array of complex numbers.</param>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.Range(AForge.Math.Complex[])">
            <summary>
              Gets the range of the magnitude values in a complex number vector.
            </summary>
            
            <param name="array">A complex number vector.</param>
            <returns>The range of magnitude values in the complex vector.</returns>
            
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.IsEqual(AForge.Math.Complex[][],AForge.Math.Complex[][],System.Double)">
            <summary>
              Compares two matrices for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="M:Accord.Math.ComplexExtensions.ComplexMatrix.IsEqual(AForge.Math.Complex[],AForge.Math.Complex[],System.Double)">
            <summary>
              Compares two vectors for equality, considering an acceptance threshold.
            </summary>
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedLuDecomposition">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.JaggedLuDecomposition.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.#ctor(System.Double[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Solve(System.Double[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.SolveTranspose(System.Double[][])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Solve(System.Double[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecomposition.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecomposition.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.REnvironment">
            <summary>
              GNU R algorithm environment. Work in progress.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.c(System.Double[])">
            <summary>
              Creates a new vector.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.matrix(System.Double[],System.Int32,System.Int32)">
            <summary>
              Creates a new matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Environments.REnvironment._">
            <summary>
              Placeholder vector definition
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.REnvironment.vec">
            <summary>
              Vector definition operator.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Environments.REnvironment.vec.vector">
            <summary>
              Inner vector object
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.#ctor(System.Double[])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Environments.REnvironment.vec"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.op_UnaryNegation(Accord.Math.Environments.REnvironment.vec)">
            <summary>
              Implements the operator -.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.op_LessThan(Accord.Math.Environments.REnvironment.vec,Accord.Math.Environments.REnvironment.vec)">
            <summary>
              Implements the operator &lt;.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.op_GreaterThan(Accord.Math.Environments.REnvironment.vec,Accord.Math.Environments.REnvironment.vec)">
            <summary>
              Implements the operator &gt;.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.op_Implicit(System.Double[])~Accord.Math.Environments.REnvironment.vec">
            <summary>
              Performs an implicit conversion from <see cref="T:System.Double[]"/>
              to <see cref="T:Accord.Math.Environments.REnvironment.vec"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.vec.op_Implicit(Accord.Math.Environments.REnvironment.vec)~System.Double[]">
            <summary>
              Performs an implicit conversion from 
              <see cref="T:Accord.Math.Environments.REnvironment.vec"/> 
              to <see cref="T:System.Double[]"/>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Environments.REnvironment.mat">
            <summary>
              Matrix definition operator.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Environments.REnvironment.mat.matrix">
            <summary>
              Inner matrix object.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.#ctor(System.Double[0:,0:])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Environments.REnvironment.mat"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.op_UnaryNegation(Accord.Math.Environments.REnvironment.mat)">
            <summary>
              Implements the operator -.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.op_LessThan(Accord.Math.Environments.REnvironment.mat,Accord.Math.Environments.REnvironment.mat)">
            <summary>
              Implements the operator &lt;.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.op_GreaterThan(Accord.Math.Environments.REnvironment.mat,Accord.Math.Environments.REnvironment.mat)">
            <summary>
               Implements the operator &gt;.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.op_Implicit(System.Double[0:,0:])~Accord.Math.Environments.REnvironment.mat">
            <summary>
              Performs an implicit conversion from 
              <see cref="T:System.Double[]"/> to 
              <see cref="T:Accord.Math.Environments.REnvironment.mat"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Environments.REnvironment.mat.op_Implicit(Accord.Math.Environments.REnvironment.mat)~System.Double[0:,0:]">
            <summary>
              Performs an implicit conversion from 
              <see cref="T:Accord.Math.Environments.REnvironment.mat"/> 
              to <see cref="T:System.Double[]"/>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Wavelets.CDF97">
            <summary>
              Cohen-Daubechies-Feauveau Wavelet Transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.#ctor(System.Int32)">
            <summary>
              Constructs a new Cohen-Daubechies-Feauveau Wavelet Transform.
            </summary>
            
            <param name="levels">The number of iterations for the 2D transform.</param>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Forward(System.Double[])">
            <summary>
              1-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Forward(System.Double[0:,0:])">
            <summary>
              2-D Forward Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Backward(System.Double[])">
            <summary>
              1-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.Backward(System.Double[0:,0:])">
            <summary>
              2-D Backward (Inverse) Discrete Wavelet Transform.
            </summary>
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.FWT97(System.Double[])">
            <summary>
              Forward biorthogonal 9/7 wavelet transform
            </summary>
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.IWT97(System.Double[])">
            <summary>
              Inverse biorthogonal 9/7 wavelet transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.FWT97(System.Double[0:,0:],System.Int32)">
            <summary>
              Forward biorthogonal 9/7 2D wavelet transform
            </summary>
            
        </member>
        <member name="M:Accord.Math.Wavelets.CDF97.IWT97(System.Double[0:,0:],System.Int32)">
            <summary>
              Inverse biorthogonal 9/7 2D wavelet transform
            </summary>
            
        </member>
        <member name="T:Accord.Math.Bessel">
            <summary>
              Bessel functions.
            </summary>
             
            <remarks>
            <para>
              Bessel functions, first defined by the mathematician Daniel 
              Bernoulli and generalized by Friedrich Bessel, are the canonical
              solutions y(x) of Bessel's differential equation.</para>
              
            <para>
              Bessel's equation arises when finding separable solutions to Laplace's
              equation and the Helmholtz equation in cylindrical or spherical coordinates.
              Bessel functions are therefore especially important for many problems of wave 
              propagation and static potentials. In solving problems in cylindrical coordinate
              systems, one obtains Bessel functions of integer order (α = n); in spherical 
              problems, one obtains half-integer orders (α = n+1/2). For example:</para>
              
              <list type="bullet">
                <item><description>
                  Electromagnetic waves in a cylindrical waveguide</description></item>
                <item><description>
                  Heat conduction in a cylindrical object</description></item>
                <item><description>
                  Modes of vibration of a thin circular (or annular) artificial 
                  membrane (such as a drum or other membranophone)</description></item>
                <item><description>
                  Diffusion problems on a lattice</description></item>
                <item><description>
                  Solutions to the radial Schrödinger equation (in spherical and
                  cylindrical coordinates) for a free particle
                <item><description>
                  Solving for patterns of acoustical radiation</description></item>
                <item><description>
                  Frequency-dependent friction in circular pipelines</description></item>
                  </description></item>
            </list>
                  
            <para>
              Bessel functions also appear in other problems, such as signal processing
              (e.g., see FM synthesis, Kaiser window, or Bessel filter).</para>
            
            <para>
              This class offers implementations of Bessel's first and second kind
              functions, with special cases for zero and for arbitrary <c>n</c>.
            </para>
            
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  Wikipedia contributors, "Bessel function,". Wikipedia, The Free 
                  Encyclopedia. Available at: http://en.wikipedia.org/wiki/Bessel_function 
                  </description></item>
              </list></para>  
            </remarks>
            
            <example>
            <code>
              // Bessel function of order 0
              actual = Bessel.J0(1);  //  0.765197686557967
              actual = Bessel.J0(5);  // -0.177596771314338
              
              // Bessel function of order n
              double j2  = Bessel.J(2, 17.3); // 0.117351128521774
              double j01 = Bessel.J(0, 1);    // 0.765197686557967
              double j05 = Bessel.J(0, 5);    // -0.177596771314338
              
            
              // Bessel function of the second kind, of order 0.
              double y0 = Bessel.Y0(64);   // 0.037067103232088
              
              // Bessel function of the second kind, of order n.
              double y2 = Bessel.Y(2, 4);  // 0.215903594603615
              double y0 = Bessel.Y(0, 64); // 0.037067103232088
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.J0(System.Double)">
            <summary>
              Bessel function of order 0.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.J(System.Double)">
            <summary>
              Bessel function of order 1.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.J(System.Int32,System.Double)">
            <summary>
              Bessel function of order <c>n</c>.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.Y0(System.Double)">
            <summary>
              Bessel function of the second kind, of order 0.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.Y(System.Double)">
            <summary>
              Bessel function of the second kind, of order 1.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.Y(System.Int32,System.Double)">
            <summary>
              Bessel function of the second kind, of order <c>n</c>.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.I0(System.Double)">
            <summary>
              Bessel function of the first kind, of order 0.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.I(System.Double)">
            <summary>
              Bessel function of the first kind, of order 1.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Bessel.I(System.Int32,System.Double)">
            <summary>
              Bessel function of the first kind, of order <c>n</c>.
            </summary>
            
            <example>
              See <see cref="T:Accord.Math.Bessel"/>
            </example>
            
        </member>
        <member name="T:Accord.Math.Beta">
            <summary>
              Beta functions.
            </summary>
            
            <remarks>
            <para>
              This class offers implementations for the many Beta functions,
              such as the <see cref="M:Accord.Math.Beta.Function(System.Double,System.Double)">Beta function itself</see>, 
              <see cref="M:Accord.Math.Beta.Log(System.Double,System.Double)">its logarithm</see>, the <see cref="M:Accord.Math.Beta.Incomplete(System.Double,System.Double,System.Double)"/>
              incomplete regularized functions and others</para>
              
            <para>
              The beta function was studied by Euler and Legendre and was given
              its name by Jacques Binet; its symbol Β is a Greek capital β rather
              than the similar Latin capital B.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  Wikipedia contributors, "Beta function,". Wikipedia, The Free 
                  Encyclopedia. Available at: http://en.wikipedia.org/wiki/Beta_function 
                  </description></item>
              </list></para>
            </remarks>
            
            <example>
            <code>
              Beta.Function(4, 0.42);       // 1.2155480852832423
              Beta.Log(4, 15.2);            // -9.46087817876467
              Beta.Incbcf(4, 2, 4.2);       // -0.23046874999999992
              Beta.Incbd(4, 2, 4.2);        // 0.7375
              Beta.PowerSeries(4, 2, 4.2);  // -3671.801280000001
              
              Beta.Incomplete(a: 5, b: 4, x: 0.5);   // 0.36328125
              Beta.IncompleteInverse(0.5, 0.6, 0.1); // 0.019145979066925722
              Beta.Multinomial(0.42, 0.5, 5.2 );     // 0.82641912952987062
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Function(System.Double,System.Double)">
            <summary>
              Beta function as gamma(a) * gamma(b) / gamma(a+b).
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Log(System.Double,System.Double)">
            <summary>
              Natural logarithm of the Beta function.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Incomplete(System.Double,System.Double,System.Double)">
            <summary>
              Incomplete (regularized) Beta function Ix(a, b).
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Incbcf(System.Double,System.Double,System.Double)">
            <summary>
              Continued fraction expansion #1 for incomplete beta integral.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Incbd(System.Double,System.Double,System.Double)">
            <summary>
              Continued fraction expansion #2 for incomplete beta integral.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.IncompleteInverse(System.Double,System.Double,System.Double)">
            <summary>
              Inverse of incomplete beta integral.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.PowerSeries(System.Double,System.Double,System.Double)">
            <summary>
              Power series for incomplete beta integral. Use when b*x
              is small and x not too close to 1.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="M:Accord.Math.Beta.Multinomial(System.Double[])">
            <summary>
              Multinomial Beta function.
            </summary>
            
            <example>
              Please see <see cref="T:Accord.Math.Beta"/>
            </example>
            
        </member>
        <member name="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno">
            <summary>
              Limited-memory Broyden–Fletcher–Goldfarb–Shanno (L-BFGS) optimization method.
            </summary>
            
            <remarks>
            <para>
              The L-BFGS algorithm is a member of the broad family of quasi-Newton optimization
              methods. L-BFGS stands for 'Limited memory BFGS'. Indeed, L-BFGS uses a limited
              memory variation of the Broyden–Fletcher–Goldfarb–Shanno (BFGS) update to approximate
              the inverse Hessian matrix (denoted by Hk). Unlike the original BFGS method which
              stores a dense  approximation, L-BFGS stores only a few vectors that represent the
              approximation implicitly. Due to its moderate memory requirement, L-BFGS method is
              particularly well suited for optimization problems with a large number of variables.</para>
            <para>
              L-BFGS never explicitly forms or stores Hk. Instead, it maintains a history of the past
              <c>m</c> updates of the position <c>x</c> and gradient <c>g</c>, where generally the history
              <c>m</c>can be short, often less than 10. These updates are used to implicitly do operations
              requiring the Hk-vector product.</para>
              
            <para>
              The framework implementation of this method is based on the original FORTRAN source code
              by Jorge Nocedal (see references below). The original FORTRAN source code of L-BFGS (for
              unconstrained problems) is available at http://www.netlib.org/opt/lbfgs_um.shar and had
              been made available under the public domain. </para>
            
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://www.netlib.org/opt/lbfgs_um.shar">
                   Jorge Nocedal. Limited memory BFGS method for large scale optimization (Fortran source code). 1990.
                   Available in http://www.netlib.org/opt/lbfgs_um.shar </a></description></item>
                <item><description>
                   Jorge Nocedal. Updating Quasi-Newton Matrices with Limited Storage. <i>Mathematics of Computation</i>,
                   Vol. 35, No. 151, pp. 773--782, 1980.</description></item>
                <item><description>
                   Dong C. Liu, Jorge Nocedal. On the limited memory BFGS method for large scale optimization.</description></item>
               </list></para>
            </remarks>
            
            <example>
            <para>
              The following example shows the basic usage of the L-BFGS solver
              to find the minimum of a function specifying its function and
              gradient. </para>
              
            <code>
            // Suppose we would like to find the minimum of the function
            // 
            //   f(x,y)  =  -exp{-(x-1)²} - exp{-(y-2)²/2}
            //
            
            // First we need write down the function either as a named
            // method, an anonymous method or as a lambda function:
            
            Func&lt;double[], double> f = (x) =>
                -Math.Exp(-Math.Pow(x[0] - 1, 2)) - Math.Exp(-0.5 * Math.Pow(x[1] - 2, 2));
            
            // Now, we need to write its gradient, which is just the
            // vector of first partial derivatives del_f / del_x, as:
            //
            //   g(x,y)  =  { del f / del x, del f / del y }
            // 
            
            Func&lt;double[], double[]> g = (x) => new double[] 
            {
                // df/dx = {-2 e^(-    (x-1)^2) (x-1)}
                2 * Math.Exp(-Math.Pow(x[0] - 1, 2)) * (x[0] - 1),
            
                // df/dy = {-  e^(-1/2 (y-2)^2) (y-2)}
                Math.Exp(-0.5 * Math.Pow(x[1] - 2, 2)) * (x[1] - 2)
            };
            
            // Finally, we can create the L-BFGS solver, passing the functions as arguments
            var lbfgs = new BroydenFletcherGoldfarbShanno(numberOfVariables: 2, function: f, gradient: g);
            
            // And then minimize the function:
            double minValue = lbfgs.Minimize();
            double[] solution = lbfgs.Solution;
            
            // The resultant minimum value should be -2, and the solution
            // vector should be { 1.0, 2.0 }. The answer can be checked on
            // Wolfram Alpha by clicking the following the link:
            
            // http://www.wolframalpha.com/input/?i=maximize+%28exp%28-%28x-1%29%C2%B2%29+%2B+exp%28-%28y-2%29%C2%B2%2F2%29%29
            
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.#ctor(System.Int32)">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]},System.Func{System.Double[]})">
            <summary>
              Creates a new instance of the L-BFGS optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            <param name="diagonal">The diagonal of the Hessian.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Minimize">
            <summary>
              Minimizes the defined function. 
            </summary>
            
            <returns>The minimum value found at the <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Solution"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Minimize(System.Double[])">
            <summary>
              Minimizes the defined function. 
            </summary>
            
            <param name="values">The initial guess values for the parameters. Default is the zero vector.</param>
            
            <returns>The minimum value found at the <see cref="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Solution"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.mcsrch(System.Double[],System.Double@,System.Double[]@,System.Double*,System.Double@,System.Int32@,System.Double[])">
            <summary>
              Finds a step which satisfies a sufficient decrease and curvature condition.
            </summary>
            
        </member>
        <member name="E:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Progress">
            <summary>
              Occurs when progress is made during the optimization.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Function">
            <summary>
              Gets or sets the function to be optimized.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Gradient">
            <summary>
              Gets or sets a function returning the gradient
              vector of the function to be optimized for a
              given value of its free parameters.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Diagonal">
            <summary>
              Gets or sets a function returning the Hessian
              diagonals to be used during optimization.
            </summary>
            
            <value>A function for the Hessian diagonal.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Parameters">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Iterations">
            <summary>
              Gets the number of iterations performed in the last
              call to <see cref="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Minimize"/>.
            </summary>
            
            <value>
              The number of iterations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.MaxIterations">
            <summary>
              Gets or sets the maximum number of iterations
              to be performed during optimization. Default
              is 0 (iterate until convergence).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Evaluations">
            <summary>
              Gets the number of function evaluations performed
              in the last call to <see cref="M:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Minimize"/>.
            </summary>
            
            <value>
              The number of evaluations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Corrections">
            <summary>
              Gets or sets the number of corrections used in the L-BFGS
              update. Recommended values are between 3 and 7. Default is 5.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.UpperBounds">
            <summary>
              Gets or sets the upper bounds of the interval
              in which the solution must be found.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.LowerBounds">
            <summary>
              Gets or sets the lower bounds of the interval
              in which the solution must be found.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Tolerance">
            <summary>
              Gets or sets the accuracy with which the solution
              is to be found. Default value is 1e-10.
            </summary>
            
            <remarks>
              The optimization routine terminates when ||G|| &lt; EPS max(1,||X||),
              where ||.|| denotes the Euclidean norm and EPS is the value for this
              property.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Precision">
            <summary>
              Gets or sets a tolerance value controlling the accuracy of the
              line search routine. If the function and gradient evaluations are
              inexpensive with respect to the cost of the iteration (which is
              sometimes the case when solving very large problems) it may be
              advantageous to set this to a small value. A typical small value
              is 0.1. This value should be greater than 1e-4. Default is 0.9.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Solution">
            <summary>
              Gets the solution found, the values of the
              parameters which optimizes the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno.Value">
            <summary>
              Gets the output of the function at the current solution.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Geometry.ConvexHullDefects">
            <summary>
              Convex Hull Defects Extractor.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.ConvexHullDefects.#ctor(System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.ConvexHullDefects"/> class.
            </summary>
            
            <param name="minDepth">The minimum depth which characterizes a convexity defect.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.ConvexHullDefects.FindDefects(System.Collections.Generic.List{AForge.IntPoint},System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
              Finds the convexity defects in a contour given a convex hull.
            </summary>
            
            <param name="contour">The contour.</param>
            <param name="convexHull">The convex hull of the contour.</param>
            <returns>A list of <see cref="T:Accord.Math.Geometry.ConvexityDefect"/>s containing each of the
            defects found considering the convex hull of the contour.</returns>
            
        </member>
        <member name="P:Accord.Math.Geometry.ConvexHullDefects.MinimumDepth">
            <summary>
            Gets or sets the minimum depth which characterizes a convexity defect.
            </summary>
            
            <value>The minimum depth.</value>
            
        </member>
        <member name="T:Accord.Math.Comparers.ElementComparer">
            <summary>
              Element-at-position comparer.
            </summary>
            
            <remarks>
              This class compares arrays by checking the value
              of a particular element at a given array index.
            </remarks>
            
            <example>
            <code>
              // We sort the arrays according to the 
              // elements at their second column.
              
              double[][] values =
              {   //                 v
                  new double[] {  0, 3, 0 },
                  new double[] {  0, 4, 1 },
                  new double[] { -1, 1, 1 },
                  new double[] { -1, 5, 4 },
                  new double[] { -2, 2, 6 },
              };
              
              // Sort the array considering only the second column
              Array.Sort(values, new ElementComparer() { Index = 1 });
              
              // The result will be
              double[][] result =
              {
                  new double[] { -1, 1, 1 },
                  new double[] { -2, 2, 6 },
                  new double[] {  0, 3, 0 },
                  new double[] {  0, 4, 1 },
                  new double[] { -1, 5, 4 },
              };
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Comparers.ElementComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.ArrayComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.GeneralComparer"/>
            <seealso cref="T:Accord.Math.Comparers.CustomComparer`1"/>
            
        </member>
        <member name="T:Accord.Math.Comparers.ElementComparer`1">
            <summary>
              Element-at-position comparer.
            </summary>
            
            <remarks>
              This class compares arrays by checking the value
              of a particular element at a given array index.
            </remarks>
            
            <example>
            <code>
              // We sort the arrays according to the 
              // elements at their second column.
              
              double[][] values =
              {   //                 v
                  new double[] {  0, 3, 0 },
                  new double[] {  0, 4, 1 },
                  new double[] { -1, 1, 1 },
                  new double[] { -1, 5, 4 },
                  new double[] { -2, 2, 6 },
              };
              
              // Sort the array considering only the second column
              Array.Sort(values, new ElementComparer() { Index = 1 });
              
              // The result will be
              double[][] result =
              {
                  new double[] { -1, 1, 1 },
                  new double[] { -2, 2, 6 },
                  new double[] {  0, 3, 0 },
                  new double[] {  0, 4, 1 },
                  new double[] { -1, 5, 4 },
              };
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Comparers.ElementComparer"/>
            <seealso cref="T:Accord.Math.Comparers.ArrayComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.GeneralComparer"/>
            <seealso cref="T:Accord.Math.Comparers.CustomComparer`1"/>
            
        </member>
        <member name="M:Accord.Math.Comparers.ElementComparer`1.Compare(`0[],`0[])">
            <summary>
              Compares two objects and returns a value indicating 
              whether one is less than, equal to, or greater than the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.ElementComparer`1.Equals(`0[],`0[])">
            <summary>
              Determines whether two instances are equal.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
            <returns>
              <c>true</c> if the specified object is equal to the other; otherwise, <c>false</c>.
            </returns>
              
        </member>
        <member name="M:Accord.Math.Comparers.ElementComparer`1.GetHashCode(`0[])">
            <summary>
              Returns a hash code for a given instance.
            </summary>
            
            <param name="obj">The instance.</param>
            
            <returns>
              A hash code for the instance, suitable for use
              in hashing algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="P:Accord.Math.Comparers.ElementComparer`1.Index">
            <summary>
              Gets or sets the element index to compare.
            </summary>
            
        </member>
        <member name="T:Accord.Math.NamespaceDoc">
            <summary>
              Mathematics, including matrix algebra and numeric optimization.
            </summary>
            
            <remarks>
            <para>
              This namespace contains a <see cref="T:Accord.Math.Matrix">matrix extension library</see>,
              along with a suite of numerical 
              <see cref="N:Accord.Math.Decompositions">matrix decomposition methods</see>, 
              <see cref="N:Accord.Math.Optimization">optimization algorithms</see> for 
              <see cref="T:Accord.Math.Optimization.AugmentedLagrangianSolver">constrained</see> and
              <see cref="T:Accord.Math.Optimization.BroydenFletcherGoldfarbShanno">unconstrained problems</see>,
              special functions and other tools for scientific applications. 
              
              Importing the Accord.Math namespace automatically brings support for the
              Extension Matrix Library, which extends common .NET data types with several
              mathematics-related extension methods.</para>
              
            <para>
              The namespace class diagram is shown below. </para>
              <img src="..\diagrams\classes\Accord.Math.png"/>
              
            <para>
              Please note that class diagrams dedicated for matrix decompositions
              are also available at <see cref="N:Accord.Math.Decompositions"/> page.
            </para>
            </remarks>
            
            <seealso cref="N:Accord.Math.Comparers"/>
            <seealso cref="N:Accord.Math.ComplexExtensions"/>
            <seealso cref="N:Accord.Math.Decompositions"/>
            <seealso cref="N:Accord.Math.Differentiation"/>
            <seealso cref="N:Accord.Math.Environments"/>
            <seealso cref="N:Accord.Math.Geometry"/>
            <seealso cref="N:Accord.Math.Kinematics"/>
            <seealso cref="N:Accord.Math.Optimization"/>
            <seealso cref="N:Accord.Math.Wavelets"/>
            
        </member>
        <member name="T:Accord.Math.ReducedRowEchelonForm">
            <summary>
              Reduced row Echelon form
            </summary>
            
        </member>
        <member name="M:Accord.Math.ReducedRowEchelonForm.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Reduces a matrix to reduced row Echelon form.
            </summary>
            
            <param name="value">The matrix to be reduced.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the reduction in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory consumption.</param>
              
        </member>
        <member name="P:Accord.Math.ReducedRowEchelonForm.Pivot">
            <summary>
              Gets the pivot indicating the position
              of the original rows before the swap.
            </summary>
            
        </member>
        <member name="P:Accord.Math.ReducedRowEchelonForm.Result">
            <summary>
              Gets the matrix in row reduced Echelon form.
            </summary>
        </member>
        <member name="P:Accord.Math.ReducedRowEchelonForm.FreeVariables">
            <summary>
              Gets the number of free variables (linear
              dependent rows) in the given matrix.
            </summary>
        </member>
        <member name="T:Accord.Math.DefaultArrayFormatProvider">
            <summary>
              Gets the default matrix representation, where each row
              is separated by a new line, and columns are separated by spaces.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              arrays and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from an array matrix to a 
              string representation:</para>
              
            <code>
              // Declare a number array
              double[] x = { 5, 6, 7, 8 };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(DefaultArrayFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              "5, 6, 7, 8"
            </code>
            
            <para>
              Converting from strings to actual matrices:</para>
            
            <code>
              // Declare an input string
              string str = "5, 6, 7, 8";
              
              // Convert the string representation to an actual number array:
              double[] array = Matrix.Parse(str, DefaultArrayFormatProvider.InvariantCulture);
              
              // array will now contain the actual number 
              // array representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.DefaultArrayFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.DefaultArrayFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.DefaultArrayFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.DefaultArrayFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.CosineTransform">
            <summary>
              Discrete Cosine Transformation.
            </summary>
            
            <remarks>
            <para>
               A discrete cosine transform (DCT) expresses a finite sequence of data points
               in terms of a sum of cosine functions oscillating at different frequencies. 
               DCTs are important to numerous applications in science and engineering, from
               lossy compression of audio (e.g. MP3) and images (e.g. JPEG) (where small 
               high-frequency components can be discarded), to spectral methods for the 
               numerical solution of partial differential equations.</para>
               
            <para>
               The use of cosine rather than sine functions is critical in these applications:
               for compression, it turns out that cosine functions are much more efficient,
               whereas for differential equations the cosines express a particular choice of 
               boundary conditions.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia contributors, "Discrete sine transform," Wikipedia, The Free Encyclopedia,
                  available at: http://en.wikipedia.org/w/index.php?title=Discrete_sine_transform </description></item>
                <item><description>
                  K. R. Castleman, Digital Image Processing. Chapter 13, p.288.
                  Prentice. Hall, 1998.</description></item>
              </list></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.CosineTransform.DCT(System.Double[])">
            <summary>
              Forward Discrete Cosine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.CosineTransform.IDCT(System.Double[])">
            <summary>
              Inverse Discrete Cosine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.CosineTransform.DCT(System.Double[0:,0:])">
            <summary>
              Forward 2D Discrete Cosine Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.CosineTransform.IDCT(System.Double[0:,0:])">
            <summary>
              Inverse 2D Discrete Cosine Transform.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.ResilientBackpropagation">
            <summary>
              Resilient Backpropagation method for unconstrained optimization.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.ResilientBackpropagation"/> class.
            </summary>
            
            <param name="parameters">The number of parameters in the function to be optimized.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.Minimize">
            <summary>
              Optimizes the defined function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.Minimize(System.Double[])">
            <summary>
              Optimizes the defined function.
            </summary>
            
            <param name="values">The initial guess values for the parameters.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)">
            <summary>
              Raises the <see cref="E:ProgressChanged"/> event.
            </summary>
            
            <param name="args">The <see cref="T:System.ComponentModel.ProgressChangedEventArgs"/> instance containing the event data.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ResilientBackpropagation.Reset(System.Double)">
            <summary>
              Resets the current update steps using the given learning rate.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.Solution">
            <summary>
              Gets the solution found; the values for  
              the parameters that optimize the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.Function">
            <summary>
              Gets or sets the function to be optimized.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.Gradient">
            <summary>
              Gets or sets a function returning the gradient
              vector of the function to be optimized for a
              given value of its free parameters.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="E:Accord.Math.Optimization.ResilientBackpropagation.ProgressChanged">
            <summary>
              Occurs when the current learning progress has changed.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.UpdateUpperBound">
            <summary>
              Gets or sets the maximum possible update step,
              also referred as delta min. Default is 50.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.UpdateLowerBound">
            <summary>
              Gets or sets the minimum possible update step,
              also referred as delta max. Default is 1e-6.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.DecreaseFactor">
            <summary>
              Gets the decrease parameter, also 
              referred as eta minus. Default is 0.5.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.IncreaseFactor">
            <summary>
              Gets the increase parameter, also
              referred as eta plus. Default is 1.2.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.Tolerance">
            <summary>
              Gets or sets the maximum change in the average log-likelihood
              after an iteration of the algorithm used to detect convergence.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.Iterations">
            <summary>
              Gets or sets the maximum number of iterations
              performed by the learning algorithm.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ResilientBackpropagation.Parameters">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>
              The number of parameters.
            </value>
            
        </member>
        <member name="T:Accord.Math.Optimization.LinearConstraintCollection">
            <summary>
              Linear Constraint Collection.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraintCollection.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LinearConstraintCollection"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraintCollection.#ctor(System.Collections.Generic.IEnumerable{Accord.Math.Optimization.LinearConstraint})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LinearConstraintCollection"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraintCollection.#ctor(System.Collections.Generic.IList{Accord.Math.Optimization.LinearConstraint})">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.LinearConstraintCollection"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.LinearConstraintCollection.CreateMatrix(System.Int32,System.Double[]@,System.Int32@)">
            <summary>
              Creates a matrix of linear constraints in canonical form.
            </summary>
            
            <param name="numberOfVariables">The number of variables in the objective function.</param>
            <param name="b">The vector of independent terms (the right hand side of the constraints).</param>
            <param name="equalities">The number of equalities in the matrix.</param>
            <returns>The matrix <c>A</c> of linear constraints.</returns>
            
        </member>
        <member name="T:Accord.Math.HilbertTransform">
            <summary>
              Discrete Hilbert Transformation.
            </summary>
            
            <remarks>
            <para>
              The discrete Hilbert transform is a transformation operating on the time
              domain. It performs a 90 degree phase shift, shifting positive frequencies
              by +90 degrees and negative frequencies by -90 degrees. It is useful to
              create analytic representation of signals. </para>
              
            <para>
              The Hilbert transform can be implemented efficiently by using the Fast
              Fourier Transform. After transforming a signal from the time-domain to
              the frequency domain, one can zero its negative frequency components and
              revert the signal back to obtain the phase shifting.</para>
              
             <para>
               By applying the Hilbert transform to a signal twice, the negative of
               the original signal is recovered.</para>
            
              <para>
                References:
                <list type="bullet">
                  <item><description>
                   Marple, S.L., "Computing the discrete-time analytic signal via FFT," IEEE 
                   Transactions on Signal Processing, Vol. 47, No.9 (September 1999). Available on:
                   http://classes.engr.oregonstate.edu/eecs/winter2009/ece464/AnalyticSignal_Sept1999_SPTrans.pdf </description></item>
                  <item><description>
                   J. F. Culling, Online, cross-indexed dictionary of DSP terms. Available on:
                   http://www.cardiff.ac.uk/psych/home2/CullingJ/frames_dict.html </description></item>
                </list>
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.HilbertTransform.FHT(System.Double[],AForge.Math.FourierTransform.Direction)">
            <summary>
              Performs the Fast Hilbert Transform over a double[] array.
            </summary>
            
        </member>
        <member name="M:Accord.Math.HilbertTransform.FHT(AForge.Math.Complex[],AForge.Math.FourierTransform.Direction)">
            <summary>
              Performs the Fast Hilbert Transform over a complex[] array.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.QuadraticConstraint">
            <summary>
              Constraint with only quadratic terms.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.NonlinearConstraint">
            <summary>
              Constraint with only linear terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.GetViolation(System.Double[])">
            <summary>
              Gets how much the constraint is being violated.
            </summary>
            
            <param name="x">The function point.</param>
            
            <returns>How much the constraint is being violated at the given point.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Linq.Expressions.Expression{System.Func{System.Double}},Accord.Math.Optimization.ConstraintType,System.Double,System.Linq.Expressions.Expression{System.Func{System.Double[]}},System.Double)">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            
            <param name="function">A lambda expression defining the left hand side of the constraint equation.</param>
            <param name="gradient">A lambda expression defining the gradient of the <paramref name="function">
            left hand side of the constraint equation</paramref>.</param>
            <param name="shouldBe">How the left hand side of the constraint should be compared to the given <paramref name="value"/>.</param>
            <param name="value">The right hand side of the constraint equation.</param>
            <param name="withinTolerance">The tolerance for violations of the constraint. Equality
              constraints should set this to a small positive value. Default is 0.</param>
            
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Func{System.Double[],System.Double},Accord.Math.Optimization.ConstraintType,System.Double,System.Func{System.Double[],System.Double[]},System.Double)">
            <summary>
              Constructs a new nonlinear constraint.
            </summary>
            
            <param name="objective">The objective function to which this constraint refers.</param>
            
            <param name="function">A lambda expression defining the left hand side of the constraint equation.</param>
            <param name="gradient">A lambda expression defining the gradient of the <paramref name="function">
            left hand side of the constraint equation</paramref>.</param>
            <param name="shouldBe">How the left hand side of the constraint should be compared to the given <paramref name="value"/>.</param>
            <param name="value">The right hand side of the constraint equation.</param>
            <param name="withinTolerance">The tolerance for violations of the constraint. Equality
              constraints should set this to a small positive value. Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.#ctor">
            <summary>
              Creates an empty nonlinear constraint.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.NonlinearConstraint.Create(Accord.Math.Optimization.IObjectiveFunction,System.Func{System.Double[],System.Double},Accord.Math.Optimization.ConstraintType,System.Double,System.Func{System.Double[],System.Double[]},System.Double)">
            <summary>
               Creates a nonlinear constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.NumberOfVariables">
            <summary>
              Gets the number of variables in the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Function">
            <summary>
              Gets the left hand side of 
              the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Gradient">
            <summary>
              Gets the gradient of the left hand
              side of the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.ShouldBe">
            <summary>
              Gets the type of the constraint.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Value">
            <summary>
              Gets the value in the right hand
              side of the constraint equation.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.NonlinearConstraint.Tolerance">
            <summary>
              Gets the violation tolerance for the constraint. Equality
              constraints should set this to a small positive value.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticConstraint.#ctor(Accord.Math.Optimization.IObjectiveFunction,System.Double[0:,0:],System.Double[],Accord.Math.Optimization.ConstraintType,System.Double,System.Double)">
             <summary>
               Constructs a new quadratic constraint in the form <c>x'Ax + x'b</c>.
             </summary>
             
             <param name="objective">The objective function to which this constraint refers.</param>
             <param name="quadraticTerms">The matrix of <c>A</c> quadratic terms.</param>
             <param name="linearTerms">The vector <c>b</c> of linear terms.</param>
             <param name="shouldBe">How the left hand side of the constraint should be compared to the given <paramref name="value"/>.</param>
             <param name="value">The right hand side of the constraint equation.</param>
             <param name="withinTolerance">The tolerance for violations of the constraint. Equality
               constraints should set this to a small positive value. Default is 0.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticConstraint.QuadraticTerms">
            <summary>
              Gets the matrix of <c>A</c> quadratic terms
              for the constraint <c>x'Ax + x'b</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticConstraint.LinearTerms">
            <summary>
              Gets the vector <c>b</c> of linear terms
              for the constraint <c>x'Ax + x'b</c>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Geometry.KCurvature">
            <summary>
              K-curvatures algorithm for local maximum contour detection.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.KCurvature.#ctor(System.Int32,AForge.DoubleRange)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Geometry.KCurvature"/> class.
            </summary>
            <param name="k">The number K of previous and posterior
              points to consider when find local extremum points.</param>
            <param name="theta">The theta angle range (in
              degrees) used to define extremum points..</param>
        </member>
        <member name="M:Accord.Math.Geometry.KCurvature.FindPeaks(System.Collections.Generic.List{AForge.IntPoint})">
            <summary>
              Finds local extremum points in the contour.
            </summary>
            <param name="contour">A list of <see cref="T:AForge.IntPoint">
            integer points</see> defining the contour.</param>
            
        </member>
        <member name="P:Accord.Math.Geometry.KCurvature.K">
            <summary>
              Gets or sets the number K of previous and posterior
              points to consider when find local extremum points.
            </summary>
        </member>
        <member name="P:Accord.Math.Geometry.KCurvature.Theta">
            <summary>
              Gets or sets the theta angle range (in
              degrees) used to define extremum points.
            </summary>
        </member>
        <member name="P:Accord.Math.Geometry.KCurvature.Suppression">
            <summary>
              Gets or sets the suppression radius to
              use during non-minimum suppression.
            </summary>
        </member>
        <member name="T:Accord.Math.Decompositions.NonnegativeMatrixFactorization">
            <summary>
              Nonnegative Matrix Factorization.
            </summary>
            
            <remarks>
            <para>
              Non-negative matrix factorization (NMF) is a group of algorithms in multivariate
              analysis and linear algebra where a matrix <c>X</c> is factorized into (usually)
              two matrices, <c>W</c> and <c>H</c>. The non-negative factorization enforces the
              constraint that the factors <c>W</c> and <c>H</c> must be non-negative, i.e., all
              elements must be equal to or greater than zero. The factorization is not unique.</para>
              
              <para>
                References:
                <list type="bullet">
                  <item><description>
                    <a href="http://en.wikipedia.org/wiki/Non-negative_matrix_factorization">
                    http://en.wikipedia.org/wiki/Non-negative_matrix_factorization </a>
                  </description></item>
                  <item><description>
                    Lee, D., Seung, H., 1999. Learning the Parts of Objects by Non-Negative
                    Matrix Factorization. Nature 401, 788–791. </description></item>
                  <item><description>
                    Michael W. Berry, et al. (June 2006). Algorithms and Applications for 
                    Approximate Nonnegative Matrix Factorization. </description></item>
                </list>
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.NonnegativeMatrixFactorization.#ctor(System.Double[0:,0:],System.Int32)">
            <summary>
              Initializes a new instance of the NMF algorithm
            </summary>
            
            <param name="value">The input data matrix (must be positive).</param>
            <param name="r">The reduced dimension.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.NonnegativeMatrixFactorization.#ctor(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the NMF algorithm
            </summary>
            
            <param name="value">The input data matrix (must be positive).</param>
            <param name="r">The reduced dimension.</param>
            <param name="maxiter">The number of iterations to perform.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.NonnegativeMatrixFactorization.compute(System.Int32)">
            <summary>
               Performs NMF using the multiplicative method
            </summary>
            
            <param name="maxiter">The maximum number of iterations</param>
            
            <remarks>
              At the end of the computation H contains the projected data
              and W contains the weights. The multiplicative method is the
              simplest factorization method.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Decompositions.NonnegativeMatrixFactorization.LeftNonnegativeFactors">
            <summary>
              Gets the nonnegative factor matrix W.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.NonnegativeMatrixFactorization.RightNonnegativeFactors">
            <summary>
              Gets the nonnegative factor matrix H.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Point3">
            <summary>
              3D point structure with X, Y, and coordinates.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Point3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Point3"/> 
              structure from the given coordinates.
            </summary>
            
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="z">The z coordinate.</param>
            
        </member>
        <member name="M:Accord.Math.Point3.#ctor(AForge.Math.Vector3)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Point3"/> 
              structure from the given coordinates.
            </summary>
            
            <param name="coordinates">The point coordinates.</param>
            
        </member>
        <member name="M:Accord.Math.Point3.op_Implicit(Accord.Math.Point3)~AForge.Math.Vector3">
            <summary>
              Performs an implicit conversion from
              <see cref="T:Accord.Math.Point3"/> to <see cref="T:AForge.Math.Vector3"/>.
            </summary>
            
            <param name="point">The point to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Point3.op_Implicit(AForge.Math.Vector3)~Accord.Math.Point3">
            <summary>
              Performs an implicit conversion from
              <see cref="T:Accord.Math.Point3"/> to <see cref="T:Accord.Math.Point3"/>.
            </summary>
            
            <param name="vector">The vector to be converted.</param>
            
            <returns>
              The result of the conversion.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Point3.FromVector(AForge.Math.Vector3)">
            <summary>
              Performs a conversion from <see cref="T:AForge.Math.Vector3"/>
              to <see cref="T:Accord.Math.Point3"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Point3.Collinear(Accord.Math.Point3,Accord.Math.Point3,Accord.Math.Point3)">
            <summary>
              Gets whether three points lie on the same line.
            </summary>
            
            <param name="p1">The first point.</param>
            <param name="p2">The second point.</param>
            <param name="p3">The third point.</param>
            
            <returns>True if there is a line passing through all
             three points; false otherwise.</returns>
            
        </member>
        <member name="M:Accord.Math.Point3.op_Equality(Accord.Math.Point3,Accord.Math.Point3)">
            <summary>
              Implements the operator !=.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Point3.op_Inequality(Accord.Math.Point3,Accord.Math.Point3)">
            <summary>
              Implements the operator !=.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Point3.Equals(Accord.Math.Point3,System.Double)">
            <summary>
              Determines whether the specified <see cref="T:Accord.Math.Point3"/> is equal to this instance.
            </summary>
            
            <param name="other">The <see cref="T:Accord.Math.Point3"/> to compare with this instance.</param>
            <param name="tolerance">The acceptance tolerance threshold to consider the instances equal.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Point3.Equals(Accord.Math.Point3)">
            <summary>
              Determines whether the specified <see cref="T:Accord.Math.Point3"/> is equal to this instance.
            </summary>
            
            <param name="other">The <see cref="T:Accord.Math.Point3"/> to compare with this instance.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:Accord.Math.Plane"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Point3.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Point3.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            
            <returns>
              A hash code for this instance, suitable for use in hashing 
              algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="P:Accord.Math.Point3.X">
            <summary>
              Gets or sets the point's X coordinate.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Point3.Y">
            <summary>
              Gets or sets the point's Y coordinate.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Point3.Z">
            <summary>
              Gets or sets the point's Z coordinate.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Point3.Origin">
            <summary>
              Gets the point at the 3D space origin: (0, 0, 0)
            </summary>
            
        </member>
        <member name="T:Accord.Math.Plane">
            <summary>
              3D Plane class with normal vector and distance from origin.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Plane.#ctor(System.Single,System.Single,System.Single)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Plane"/> object
              passing through the <see cref="P:Accord.Math.Point3.Origin"/>.
            </summary>
            
            <param name="a">The first component of the plane's normal vector.</param>
            <param name="b">The second component of the plane's normal vector.</param>
            <param name="c">The third component of the plane's normal vector.</param>
            
        </member>
        <member name="M:Accord.Math.Plane.#ctor(AForge.Math.Vector3)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Plane"/> object
              passing through the <see cref="P:Accord.Math.Point3.Origin"/>.
            </summary>
            
            <param name="normal">The plane's normal vector.</param>
            
        </member>
        <member name="M:Accord.Math.Plane.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Plane"/> class.
            </summary>
            
            <param name="a">The first component of the plane's normal vector.</param>
            <param name="b">The second component of the plane's normal vector.</param>
            <param name="c">The third component of the plane's normal vector.</param>
            
            <param name="offset">The distance from the plane to the origin.</param>
            
        </member>
        <member name="M:Accord.Math.Plane.#ctor(AForge.Math.Vector3,System.Single)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Plane"/> class.
            </summary>
            
            <param name="normal">The plane's normal vector.</param>
            <param name="offset">The distance from the plane to the origin.</param>
            
        </member>
        <member name="M:Accord.Math.Plane.FromPoints(Accord.Math.Point3,Accord.Math.Point3,Accord.Math.Point3)">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Plane"/> object from three points.
            </summary>
            
            <param name="point1">The first point.</param>
            <param name="point2">The second point.</param>
            <param name="point3">The third point.</param>
            
            <returns>A <see cref="T:Accord.Math.Plane"/> passing through the three points.</returns>
            
        </member>
        <member name="M:Accord.Math.Plane.DistanceToPoint(Accord.Math.Point3)">
            <summary>
              Computes the distance from point to plane.
            </summary>
            
            <param name="point">The point to have its distance from the plane computed.</param>
            
            <returns>The distance from <paramref name="point"/> to this plane.</returns>
            
        </member>
        <member name="M:Accord.Math.Plane.Normalize">
            <summary>
              Normalizes this plane by dividing its components
              by the <see cref="P:Accord.Math.Plane.Normal"/> vector's norm.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Plane.op_Equality(Accord.Math.Plane,Accord.Math.Plane)">
            <summary>
              Implements the operator !=.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Plane.op_Inequality(Accord.Math.Plane,Accord.Math.Plane)">
            <summary>
              Implements the operator !=.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Plane.Equals(Accord.Math.Plane,System.Double)">
            <summary>
              Determines whether the specified <see cref="T:Accord.Math.Plane"/> is equal to this instance.
            </summary>
            
            <param name="other">The <see cref="T:Accord.Math.Plane"/> to compare with this instance.</param>
            <param name="tolerance">The acceptance tolerance threshold to consider the instances equal.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.Equals(Accord.Math.Plane)">
            <summary>
              Determines whether the specified <see cref="T:Accord.Math.Plane"/> is equal to this instance.
            </summary>
            
            <param name="other">The <see cref="T:Accord.Math.Plane"/> to compare with this instance.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:Accord.Math.Plane"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.Equals(System.Object)">
            <summary>
              Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.GetHashCode">
            <summary>
              Returns a hash code for this instance.
            </summary>
            
            <returns>
              A hash code for this instance, suitable for use in hashing 
              algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.ToString(System.String,System.IFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <param name="format">The format.</param>
            <param name="formatProvider">The format provider.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.ToString(System.Char)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <param name="variable">The variable to put on the left hand side. Can
              be either 'x', 'y' or 'z'.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Plane.ToString(System.Char,System.IFormatProvider)">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <param name="variable">The variable to put on the left hand side. Can
              be either 'x', 'y' or 'z'.</param>
            <param name="formatProvider">The format provider.</param>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Plane.Normal">
            <summary>
              Gets the plane's normal vector.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Plane.A">
            <summary>
              Gets or sets the constant <c>a</c> in the plane
              definition <c>a * x + b * y + c * z + d = 0</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Plane.B">
            <summary>
              Gets or sets the constant <c>b</c> in the plane
              definition <c>a * x + b * y + c * z + d = 0</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Plane.C">
            <summary>
              Gets or sets the constant <c>c</c> in the plane
              definition <c>a * x + b * y + c * z + d = 0</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Plane.Offset">
            <summary>
              Gets or sets the distance offset 
              between the plane and the origin.
            </summary>
            
        </member>
        <member name="T:Accord.Math.RelativeParameterConvergence">
            <summary>
              Relative parameter change convergence criteria.
            </summary>
            
            <remarks>
              This class can be used to track progress and convergence
              of methods which rely on the maximum relative change of
              the values within a parameter vector.
            </remarks>
            
            <example>
            <code>
              // Converge if the maximum change amongst all parameters is less than 0.1:
              var criteria = new RelativeParameterConvergence(iterations: 0, tolerance: 0.1);
            
              int progress = 1;
              double[] parameters = { 12345.6, 952.12, 1925.1 };
              
              do
              {
                  // Do some processing...
            
                  // Update current iteration information:
                  criteria.NewValues = parameters.Divide(progress++);
            
              } while (!criteria.HasConverged);
            
            
              // The method will converge after reaching the 
              // maximum of 11 iterations with a final value
              // of { 1234.56, 95.212, 192.51 }:
            
              int iterations = criteria.CurrentIteration; // 11
              var v = criteria.OldValues; // { 1234.56, 95.212, 192.51 }
            
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.RelativeParameterConvergence.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.RelativeParameterConvergence"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.RelativeParameterConvergence.#ctor(System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.RelativeParameterConvergence"/> class.
            </summary>
            
            <param name="iterations">The maximum number of iterations which should be
              performed by the iterative algorithm. Setting to zero indicates there
              is no maximum number of iterations. Default is 0.</param>
            <param name="tolerance">The maximum relative change in the watched value
              after an iteration of the algorithm used to detect convergence.
              Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.RelativeParameterConvergence.Clear">
            <summary>
              Clears this instance.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.Tolerance">
            <summary>
              Gets or sets the maximum change in the watched value
              after an iteration of the algorithm used to detect convergence.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.Iterations">
            <summary>
              Gets or sets the maximum number of iterations
              performed by the iterative algorithm.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.Delta">
            <summary>
              Gets the maximum relative parameter
              change after the last iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.OldValues">
            <summary>
              Gets or sets the watched value before the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.NewValues">
            <summary>
              Gets or sets the watched value after the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.CurrentIteration">
            <summary>
              Gets or sets the current iteration number.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.HasDiverged">
            <summary>
              Gets whether the algorithm has diverged.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeParameterConvergence.HasConverged">
            <summary>
              Gets whether the algorithm has converged.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.IntegerArrayComparer">
            <summary>
              Elementwise comparer for integer arrays.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.ArrayComparer`1">
            <summary>
              Elementwise comparer for arrays.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Comparers.ArrayComparer`1.Equals(`0[],`0[])">
            <summary>
              Determines whether two instances are equal.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            <returns>
              <c>true</c> if the specified object is equal to the other; otherwise, <c>false</c>.
            </returns>
              
        </member>
        <member name="M:Accord.Math.Comparers.ArrayComparer`1.GetHashCode(`0[])">
            <summary>
              Returns a hash code for a given instance.
            </summary>
            
            <param name="obj">The instance.</param>
            
            <returns>
              A hash code for the instance, suitable for use 
              in hashing algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="T:Accord.Math.OctaveMatrixFormatProvider">
            <summary>
              Format provider for the matrix format used by Octave.
            </summary>
            
            <remarks>
              This class can be used to convert to and from C#
              matrices and their string representation. Please 
              see the example for details.
            </remarks>
            
            <remarks>
              This class can be used to convert to and from C#
              matrices and their string representation. Please 
              see the example for details.
            </remarks>
            
            <example>
            <para>
              Converting from a multidimensional matrix to a 
              string representation:</para>
              
            <code>
              // Declare a number array
              double[,] x = 
              {
                 { 1, 2, 3, 4 },
                 { 5, 6, 7, 8 },
              };
              
              // Convert the aforementioned array to a string representation:
              string str = x.ToString(OctaveMatrixFormatProvider.CurrentCulture);
              
              // the final result will be equivalent to
              "[ 1, 2, 3, 4; 5, 6, 7, 8 ]"
            </code>
            
            <para>
              Converting from strings to actual matrices:</para>
            
            <code>
              // Declare an input string
              string str = "[ 1, 2, 3, 4; 5, 6, 7, 8 ]";
              
              // Convert the string representation to an actual number array:
              double[,] matrix = Matrix.Parse(str, OctaveMatrixFormatProvider.InvariantCulture);
              
              // matrix will now contain the actual multidimensional 
              // matrix representation of the given string.
            </code>
            </example>
            
            <seealso cref="T:Accord.Math.Matrix"/>
            <seealso cref="T:Accord.Math.CSharpMatrixFormatProvider"/>
            
            <seealso cref="T:Accord.Math.CSharpJaggedMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.CSharpArrayFormatProvider"/>
            
            <seealso cref="T:Accord.Math.OctaveMatrixFormatProvider"/>
            <seealso cref="T:Accord.Math.OctaveArrayFormatProvider"/>
            
        </member>
        <member name="M:Accord.Math.OctaveMatrixFormatProvider.#ctor(System.IFormatProvider)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.OctaveMatrixFormatProvider"/> class.
            </summary>
            
        </member>
        <member name="P:Accord.Math.OctaveMatrixFormatProvider.CurrentCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the CultureInfo used by the current thread.
            </summary>
            
        </member>
        <member name="P:Accord.Math.OctaveMatrixFormatProvider.InvariantCulture">
            <summary>
              Gets the IMatrixFormatProvider which uses the invariant system culture.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.LuDecompositionF">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.LuDecompositionF.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.#ctor(System.Single[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Solve(System.Single[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.SolveTranspose(System.Single[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionF.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
              Please see remarks for important information regarding
              numerical stability when using this method.
            </summary>
            
            <remarks>
              Please keep in mind this is not one of the most reliable methods
              for checking singularity of a matrix. For a more reliable method,
              please use <see cref="M:Accord.Math.Matrix.IsSingular(System.Double[0:,0:])"/> or the 
              <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition"/>.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionF.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.GaussNewton">
            <summary>
              Gauss-Newton algorithm for solving Least-Squares problems.
            </summary>
            
            <remarks>
              This class isn't suitable for most real-world problems. Instead, this class
              is intended to be use as a baseline comparison to help debug and check other
              optimization methods, such as <see cref="T:Accord.Math.Optimization.LevenbergMarquardt"/>.
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.GaussNewton.#ctor(System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Optimization.GaussNewton"/> class.
            </summary>
            
            <param name="parameters">The number of variables (free parameters)
              in the objective function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GaussNewton.Minimize(System.Double[][],System.Double[])">
            <summary>
              Attempts to find the best values for the parameter vector
              minimizing the discrepancy between the generated outputs
              and the expected outputs for a given set of input data.
            </summary>
            
            <param name="inputs">A set of input data.</param>
            <param name="outputs">The values associated with each 
              vector in the <paramref name="inputs"/> data.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GaussNewton.ComputeError(System.Double[][],System.Double[])">
            <summary>
              Compute model error for a given data set.
            </summary>
            
            <param name="input">The input points.</param>
            <param name="output">The output points.</param>
            
            <returns>The sum of squared errors for the data.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Function">
            <summary>
              Gets or sets a parameterized model function mapping input vectors
              into output values, whose optimum parameters must be found.
            </summary>
            
            <value>
              The function to be optimized.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Gradient">
            <summary>
              Gets or sets a function that computes the gradient vector in respect
              to the function parameters, given a set of input and output values.
            </summary>
            
            <value>
              The gradient function.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Parameters">
            <summary>
              Gets the number of variables (free parameters) in the optimization problem.
            </summary>
            
            <value>
              The number of parameters.
            </value>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Hessian">
            <summary>
              Gets the approximate Hessian matrix of second derivatives
              created during the last algorithm iteration.
            </summary>
            
            <remarks>
            <para>
              Please note that this value is actually just an approximation to the
              actual Hessian matrix using the outer Jacobian approximation (H ~ J'J).
            </para>
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Solution">
            <summary>
              Gets the solution found, the values of the parameters which
              optimizes the function, in a least squares sense.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Residuals">
            <summary>
              Gets the vector of residuals computed in the last iteration.
              The residuals are computed as <c>(y - f(w, x))</c>, in which 
              <c>y</c> are the expected output values, and <c>f</c> is the
              parameterized model function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Jacobian">
            <summary>
              Gets the Jacobian matrix of first derivatives computed in the
              last iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.Deltas">
            <summary>
              Gets the vector of coefficient updates computed in the last iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GaussNewton.StandardErrors">
            <summary>
              Gets standard error for each parameter in the solution.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergModel">
             <summary>
               Denavit Hartenberg model for joints.
             </summary>
             
             <remarks>
             <para>
               This class represents either a model itself or a submodel 
               when used with a <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNode"> 
               DenavitHartenbergModelCombinator instance</see>. </para>
             
             <para>
               References:
               <list type="bullet">
                 <item><description>
                   Wikipedia contributors, "Denavit-Hartenberg parameters," Wikipedia,
                   The Free Encyclopedia, available at: 
                   http://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters 
                   </description></item>
               </list></para>
             </remarks>
            
             <example>
             <para>
               The following example shows the creation and animation
               of a 2-link planar manipulator.</para>
             
             <code>
               // Create the DH-model at location (0, 0, 0) 
            	  DenavitHartenbergModel model = new DenavitHartenbergModel();
            	  
            	  // Add the first joint
            	  model.Joints.Add(alpha: 0, theta: Math.PI / 4, radius: 35, offset: 0);
            	  
               // Add the second joint
            	  model.Joints.Add(alpha: 0, theta: -Math.PI / 3, radius: 35, offset: 0);
            	  
            	  // Now move the arm
            	  model.Joints[0].Parameters.Theta += Math.PI / 10;
            	  model.Joints[1].Parameters.Theta -= Math.PI / 10;
            	  
            	  // Calculate the model
            	  model.Compute();
            	</code>
             </example>
             
             <seealso cref="T:Accord.Math.Kinematics.DenavitHartenbergNode"/>
             <seealso cref="T:Accord.Math.Kinematics.DenavitHartenbergParameters"/>
             
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.#ctor(AForge.Math.Vector3)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergModel"/>
              class given a specified model position in 3D space.
            </summary>
            
            <param name="position">The model's position in 3D space. Default is (0,0,0).</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergModel"/>
              class at the origin of the space (0,0,0).
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.Compute">
            <summary>
              Computes the entire model, calculating the 
              final position for each joint in the model.
            </summary>
            
            <returns>The model transformation matrix</returns>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.Compute(Accord.Math.Kinematics.DenavitHartenbergModel)">
            <summary>
              Calculates the entire model given it is attached to a parent model and computes each joint position.
            </summary>
            
            <param name="parent">Parent model this model is attached to.</param>
            
            <returns>Model transform matrix of the whole chain (parent + model).</returns>
            
            <remarks>This function assumes the parent model has already been calculated.</remarks>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.GetEnumerator">
            <summary>
              Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
              An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergModel.System#Collections#IEnumerable#GetEnumerator">
            <summary>
              Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
              An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergModel.Joints">
            <summary>
              Gets the model kinematic chain.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergModel.Position">
            <summary>
              Gets or sets the model position.
            </summary>
              
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergModel.Transform">
            <summary>
              Gets the transformation matrix T for the full model, given
              as T = T_0 * T_1 * T_2 ...T_n in which T_i is the transform
              matrix for each joint in the model.
            </summary>
            
        </member>
        <member name="T:Accord.Math.RelativeConvergence">
            <summary>
              Relative convergence criteria.
            </summary>
            
            <remarks>
              This class can be used to track progress and convergence
              of methods which rely on the relative change of a value.
            </remarks>
            
            <example>
            <code>
              // Create a new convergence criteria with unlimited iterations
              var criteria = new RelativeConvergence(iterations: 0, tolerance: 0.1);
              
              int progress = 1;
              
              do
              {
                  // Do some processing...
              
              
                  // Update current iteration information:
                  criteria.NewValue = 12345.6 / progress++;
              
              } while (!criteria.HasConverged);
              
              
              // The method will converge after reaching the 
              // maximum of 11 iterations with a final value
              // of 1234.56:
              
              int iterations = criteria.CurrentIteration; // 11
              double value = criteria.OldValue; // 1234.56
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.RelativeConvergence.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.RelativeConvergence"/> class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.RelativeConvergence.#ctor(System.Int32,System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.RelativeConvergence"/> class.
            </summary>
            
            <param name="iterations">The maximum number of iterations which should be
              performed by the iterative algorithm. Setting to zero indicates there
              is no maximum number of iterations. Default is 0.</param>
            <param name="tolerance">The maximum relative change in the watched value
              after an iteration of the algorithm used to detect convergence.
              Default is 0.</param>
            
        </member>
        <member name="M:Accord.Math.RelativeConvergence.#ctor(System.Int32,System.Double,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.RelativeConvergence"/> class.
            </summary>
            
            <param name="iterations">The maximum number of iterations which should be
              performed by the iterative algorithm. Setting to zero indicates there
              is no maximum number of iterations. Default is 0.</param>
            <param name="tolerance">The maximum relative change in the watched value
              after an iteration of the algorithm used to detect convergence.
              Default is 0.</param>
            <param name="checks">The minimum number of convergence checks that the
              iterative algorithm should pass before convergence can be declared
              reached.</param>
            
        </member>
        <member name="M:Accord.Math.RelativeConvergence.Clear">
            <summary>
              Resets this instance, reverting all iteration statistics
              statistics (number of iterations, last error) back to zero.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.Tolerance">
            <summary>
              Gets or sets the maximum relative change in the watched value
              after an iteration of the algorithm used to detect convergence.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.Iterations">
            <summary>
              Gets or sets the maximum number of iterations
              performed by the iterative algorithm.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.OldValue">
            <summary>
              Gets or sets the watched value before the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.NewValue">
            <summary>
              Gets or sets the watched value after the iteration.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.CurrentIteration">
            <summary>
              Gets or sets the current iteration number.
            </summary>
            
        </member>
        <member name="P:Accord.Math.RelativeConvergence.HasConverged">
            <summary>
              Gets whether the algorithm has converged.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.StableComparer`1">
            <summary>
              Stable comparer for stable sorting algorithm.
            </summary>
            
            <typeparam name="T">The type of objects to compare.</typeparam>
            
            <remarks>
              This class helps sort the elements of an array without swapping
              elements which are already in order. This comprises a <c>stable</c>
              sorting algorithm. This class is used by the <see cref="M:Accord.Math.Tools.StableSort``1(``0[],System.Int32[]@)"/> method to produce a stable sort
              of its given arguments.
            </remarks>
            
            <example>
              In order to use this class, please use <see cref="M:Accord.Math.Tools.StableSort``1(``0[],System.Int32[]@)"/>.
            </example>
            
            <seealso cref="T:Accord.Math.Comparers.ElementComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.ArrayComparer`1"/>
            <seealso cref="T:Accord.Math.Comparers.GeneralComparer"/>
            <seealso cref="T:Accord.Math.Comparers.CustomComparer`1"/>
            
        </member>
        <member name="M:Accord.Math.Comparers.StableComparer`1.#ctor(System.Comparison{`0})">
            <summary>
              Constructs a new instance of the <see cref="T:Accord.Math.Comparers.StableComparer`1"/> class.
            </summary>
            
            <param name="comparison">The comparison function.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.StableComparer`1.Compare(System.Collections.Generic.KeyValuePair{System.Int32,`0},System.Collections.Generic.KeyValuePair{System.Int32,`0})">
            <summary>
              Compares two objects and returns a value indicating
              whether one is less than, equal to, or greater than
              the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
            <returns>A signed integer that indicates the relative values of x and y.</returns>
            
        </member>
        <member name="T:Accord.Math.Optimization.ConjugateGradientMethod">
            <summary>
              Conjugate gradient direction update formula.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientMethod.FletcherReeves">
            <summary>
              Fletcher-Reeves formula.
            </summary>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientMethod.PolakRibiere">
            <summary>
              Polak-Ribière formula.
            </summary>
            
            <remarks>
              The Polak-Ribière is known to perform better for non-quadratic functions.
            </remarks>
            
        </member>
        <member name="F:Accord.Math.Optimization.ConjugateGradientMethod.PositivePolakRibiere">
            <summary>
              Polak-Ribière formula.
            </summary>
            
            <remarks>
              The Polak-Ribière is known to perform better for non-quadratic functions.
              The positive version B=max(0,Bpr) provides a direction reset automatically.
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Optimization.ConjugateGradient">
            <summary>
              Conjugate Gradient (CG) optimization method.
            </summary>
            
            <remarks>
            <para>
              In mathematics, the conjugate gradient method is an algorithm for the numerical solution of
              particular systems of linear equations, namely those whose matrix is symmetric and positive-
              definite. The conjugate gradient method is an iterative method, so it can be applied to sparse
              systems that are too large to be handled by direct methods. Such systems often arise when
              numerically solving partial differential equations. The nonlinear conjugate gradient method 
              generalizes the conjugate gradient method to nonlinear optimization (Wikipedia, 2011).</para>
            <para>
              T</para>
            <para>
              The framework implementation of this method is based on the original FORTRAN source code
              by Jorge Nocedal (see references below). The original FORTRAN source code of CG+ (for large
              scale unconstrained problems) is available at http://users.eecs.northwestern.edu/~nocedal/CG+.html
              and had been made freely available for educational or commercial use. The original authors
              expect that all publications describing work using this software quote the (Gilbert and Nocedal, 1992)
              reference given below.</para>
            
            <para>
              References:
              <list type="bullet">
                <item><description><a href="http://users.eecs.northwestern.edu/~nocedal/CG+.html">
                   J. C. Gilbert and J. Nocedal. Global Convergence Properties of Conjugate Gradient
                   Methods for Optimization, (1992) SIAM J. on Optimization, 2, 1.</a></description></item>
                <item><description>
                   Wikipedia contributors, "Nonlinear conjugate gradient method," Wikipedia, The Free 
                   Encyclopedia, http://en.wikipedia.org/w/index.php?title=Nonlinear_conjugate_gradient_method
                   (accessed December 22, 2011).</description></item>
                <item><description>
                   Wikipedia contributors, "Conjugate gradient method," Wikipedia, The Free Encyclopedia,
                   http://en.wikipedia.org/w/index.php?title=Conjugate_gradient_method 
                   (accessed December 22, 2011).</description></item>
               </list></para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.#ctor(System.Int32)">
            <summary>
              Creates a new instance of the CG optimization algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.#ctor(System.Int32,System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Creates a new instance of the CG optimization algorithm.
            </summary>
            
            <param name="parameters">The number of free parameters in the function to be optimized.</param>
            <param name="function">The function to be optimized.</param>
            <param name="gradient">The gradient of the function.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.Minimize">
            <summary>
              Optimizes the defined function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.ConjugateGradient.Minimize(System.Double[])">
            <summary>
              Optimizes the defined function.
            </summary>
            
            <param name="values">The initial guess values for the parameters.</param>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Tolerance">
            <summary>
              Gets or sets the relative difference threshold
              to be used as stopping criteria between two
              iterations. Default is 0 (iterate until convergence). 
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.MaxIterations">
            <summary>
              Gets or sets the maximum number of iterations
              to be performed during optimization. Default
              is 0 (iterate until convergence).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Method">
            <summary>
              Gets or sets the conjugate gradient update 
              method to be used during optimization.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Iterations">
            <summary>
              Gets the number of iterations performed 
              in the last call to <see cref="M:Accord.Math.Optimization.ConjugateGradient.Minimize"/>.
            </summary>
            
            <value>
              The number of iterations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Evaluations">
            <summary>
              Gets the number of function evaluations performed
              in the last call to <see cref="M:Accord.Math.Optimization.ConjugateGradient.Minimize"/>.
            </summary>
            
            <value>
              The number of evaluations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Searches">
            <summary>
              Gets the number of linear searches performed
              in the last call to <see cref="M:Accord.Math.Optimization.ConjugateGradient.Minimize"/>.
            </summary>
            
        </member>
        <member name="E:Accord.Math.Optimization.ConjugateGradient.Progress">
            <summary>
              Occurs when progress is made during the optimization.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Function">
            <summary>
              Gets or sets the function to be optimized.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Gradient">
            <summary>
              Gets or sets a function returning the gradient
              vector of the function to be optimized for a
              given value of its free parameters.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Parameters">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Solution">
            <summary>
              Gets the solution found, the values of the 
              parameters which optimizes the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.ConjugateGradient.Value">
            <summary>
              Gets the output of the function at the current solution.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Normal">
            <summary>
              Normal distribution functions.
            </summary>
             
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Cephes Math Library, http://www.netlib.org/cephes/ </description></item>
                <item><description>
                  George Marsaglia, Evaluating the Normal Distribution, 2004.
                  Available in: http://www.jstatsoft.org/v11/a05/paper </description></item>
              </list>
            </remarks>
            
            <example>
            <para>
              The following example shows the normal usages for the Normal functions:
            </para>
            
            <code>
              // Compute standard precision functions
              double phi  = Normal.Function(0.42);     //  0.66275727315175048
              double phic = Normal.Complemented(0.42); //  0.33724272684824952
              double inv  = Normal.Inverse(0.42);      // -0.20189347914185085
              
              // Compute at the limits
              double phi  = Normal.Function(16.6);     //  1.0
              double phic = Normal.Complemented(16.6); //  3.4845465199504055E-62
            </code>
            
            </example>
            
        </member>
        <member name="M:Accord.Math.Normal.Function(System.Double)">
            <summary>
              Normal cumulative distribution function.
            </summary>
            
            <returns>
              The area under the Gaussian p.d.f. integrated
              from minus infinity to the given value.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Normal.Complemented(System.Double)">
            <summary>
              Complemented cumulative distribution function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Normal.Inverse(System.Double)">
            <summary>
               Normal (Gaussian) inverse cumulative distribution function.
            </summary>
            
            <remarks>
            <para>
               For small arguments <c>0 &lt; y &lt; exp(-2)</c>, the program computes <c>z =
               sqrt( -2.0 * log(y) )</c>;  then the approximation is <c>x = z - log(z)/z  - 
               (1/z) P(1/z) / Q(1/z)</c>.</para>
            <para>
               There are two rational functions P/Q, one for <c>0 &lt; y &lt; exp(-32)</c> and
               the other for <c>y</c> up to <c>exp(-2)</c>. For larger arguments, <c>w = y - 0.5</c>,
               and  <c>x/sqrt(2pi) = w + w^3 * R(w^2)/S(w^2))</c>.</para>
            </remarks>
            
            <returns>
               Returns the value, <c>x</c>, for which the area under the Normal (Gaussian)
               probability density function (integrated from minus infinity to <c>x</c>) is
               equal to the argument <c>y</c> (assumes mean is zero, variance is one).
            </returns>
            
        </member>
        <member name="M:Accord.Math.Normal.HighAccuracyFunction(System.Double)">
            <summary>
              High-accuracy Normal cumulative distribution function.
            </summary>
            
            <remarks>
            <para>
              The following formula provide probabilities with an absolute error
              less than 8e-16.</para>
            <para>
              References:
               - George Marsaglia, Evaluating the Normal Distribution, 2004.
                 Available in: http://www.jstatsoft.org/v11/a05/paper </para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Normal.HighAccuracyComplemented(System.Double)">
            <summary>
              High-accuracy Complementary normal distribution function.
            </summary>
            
            <remarks>
            <para>
              This function uses 9 tabled values to provide tail values of the
              normal distribution, also known as complementary Phi, with an
              absolute error of 1e-14 ~ 1e-16.
            </para>
              References:
               - George Marsaglia, Evaluating the Normal Distribution, 2004.
                 Available in: http://www.jstatsoft.org/v11/a05/paper
            </remarks>
            
            <returns>
              The area under the Gaussian p.d.f. integrated
              from the given value to positive infinity.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Normal.Bivariate(System.Double,System.Double,System.Double)">
            <summary>
              Bivariate normal cumulative distribution function.
            </summary>
            
            <param name="x">The value of the first variate.</param>
            <param name="y">The value of the second variate.</param>
            <param name="rho">The correlation coefficient between x and y. This can be computed
            from a covariance matrix C as  <code>rho = C_12 / (sqrt(C_11) * sqrt(C_22))</code>.</param>
            <returns></returns>
            
        </member>
        <member name="M:Accord.Math.Normal.BivariateComplemented(System.Double,System.Double,System.Double)">
            <summary>
              Complemented bivariate normal cumulative distribution function.
            </summary>
            
            <param name="x">The value of the first variate.</param>
            <param name="y">The value of the second variate.</param>
            <param name="rho">The correlation coefficient between x and y. This can be computed
            from a covariance matrix C as  <code>rho = C_12 / (sqrt(C_11) * sqrt(C_22))</code>.</param>
            <returns></returns>
            
        </member>
        <member name="M:Accord.Math.Normal.BVND(System.Double,System.Double,System.Double)">
            <summary>
              A function for computing bivariate normal probabilities. 
              BVND calculates the probability that X > DH and Y > DK.
            </summary>
            
            <remarks>
            <para>
              This method is based on the work done by Alan Genz, Department of 
              Mathematics, Washington State University. Pullman, WA 99164-3113
              Email: alangenz@wsu.edu. This work was shared under a 3-clause BSD
              license. Please see source file for more details and the actual
              license text.</para>
              
            <para>
              This function is based on the method described by Drezner, Z and G.O.
              Wesolowsky, (1989), On the computation of the bivariate normal integral,
              Journal of Statist. Comput. Simul. 35, pp. 101-107, with major modifications
              for double precision, and for |R| close to 1.</para>
            </remarks>
            
        </member>
        <member name="T:Accord.Math.Decompositions.CholeskyDecomposition">
            <summary>
                Cholesky Decomposition of a symmetric, positive definite matrix.
            </summary>
            <remarks>
              <para>
                For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
                lower triangular matrix <c>L</c> so that <c>A = L * L'</c>.
                If the matrix is not symmetric or positive definite, the constructor returns a partial 
                decomposition and sets two internal variables that can be queried using the
                <see cref="P:Accord.Math.Decompositions.CholeskyDecomposition.Symmetric"/> and <see cref="P:Accord.Math.Decompositions.CholeskyDecomposition.PositiveDefinite"/> properties.</para>
              <para>
                Any square matrix A with non-zero pivots can be written as the product of a
                lower triangular matrix L and an upper triangular matrix U; this is called
                the LU decomposition. However, if A is symmetric and positive definite, we
                can choose the factors such that U is the transpose of L, and this is called
                the Cholesky decomposition. Both the LU and the Cholesky decomposition are
                used to solve systems of linear equations.</para>
              <para>
                When it is applicable, the Cholesky decomposition is twice as efficient
                as the LU decomposition.</para>
               </remarks>
               
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.#ctor(System.Double[0:,0:])">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            <param name="value">The matrix to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square root free LDLt decomposition,
            false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>Constructs a new Cholesky Decomposition.</summary>
            
            <param name="value">The matrix to be decomposed.</param>
            <param name="robust">True to perform a square-root free LDLt decomposition,
            false otherwise.</param>
            <param name="lowerTriangular">True to assume the <paramref name="value">value
            matrix</paramref> is a lower triangular symmetric matrix, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[0:,0:])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is not symmetric and positive definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[0:,0:],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[])">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Solve(System.Double[],System.Boolean)">
            <summary>Solves a set of equation systems of type <c>A * x = b</c>.</summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Vector <c>x</c> so that <c>L * L' * x = b</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.NonSymmetricMatrixException">Matrix is not symmetric.</exception>
            <exception cref="T:System.NonPositiveDefiniteMatrixException">Matrix is not positive-definite.</exception>
            <param name="inPlace">True to compute the solving in place, false otherwise.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Inverse">
            <summary>
              Computes the inverse of the decomposed matrix.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.FromLeftTriangularMatrix(System.Double[0:,0:])">
            <summary>
              Creates a new Cholesky decomposition directly from
              an already computed left triangular matrix <c>L</c>.
            </summary>
            <param name="leftTriangular">The left triangular matrix from a Cholesky decomposition.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.CholeskyDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Symmetric">
             <summary>
               Returns <see langword="true"/> if the matrix is symmetric.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.PositiveDefinite">
             <summary>
               Returns <see langword="true"/> if the matrix is positive definite.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.LeftTriangularFactor">
             <summary>
               Returns the left (lower) triangular factor <c>L</c> so that <c>A = L * D * L'</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.DiagonalMatrix">
             <summary>
               Returns the block diagonal matrix of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Diagonal">
             <summary>
               Returns the one-dimensional array of diagonal elements in a LDLt decomposition.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Determinant">
             <summary>
               Returns the determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.LogDeterminant">
             <summary>
               Returns the log-determinant of the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.CholeskyDecomposition.Nonsingular">
             <summary>
               Returns if the matrix is non-singular (i.e. invertible).
             </summary>
            
        </member>
        <member name="T:Accord.Math.Geometry.Circle">
            <summary>
              2D circle class.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.#ctor">
            <summary>
              Creates a new unit <see cref="T:Accord.Math.Geometry.Circle"/> at the origin.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.#ctor(System.Single,System.Single,System.Double)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Geometry.Circle"/> with the given radius 
              centered at the given <c>x</c> and <c>y</c> coordinates.
            </summary>
            
            <param name="x">The x-coordinate of the circle's center.</param>
            <param name="y">The y-coordinate of the circle's center.</param>
            <param name="radius">The circle radius.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.#ctor(System.Double,System.Double,System.Double)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Geometry.Circle"/> with the given radius 
              centered at the given <c>x</c> and <c>y</c> coordinates.
            </summary>
            
            <param name="x">The x-coordinate of the circle's center.</param>
            <param name="y">The y-coordinate of the circle's center.</param>
            <param name="radius">The circle radius.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.#ctor(AForge.Point,System.Double)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Geometry.Circle"/> with the given radius 
              centered at the given center point coordinates.
            </summary>
            
            <param name="origin">The point at the circle's center.</param>
            <param name="radius">The circle radius.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.#ctor(AForge.Point,AForge.Point,AForge.Point)">
            <summary>
              Creates a new <see cref="T:Accord.Math.Geometry.Circle"/> from three non-linear points.
            </summary>
            
            <param name="p1">The first point.</param>
            <param name="p2">The second point.</param>
            <param name="p3">The third point.</param>
            
        </member>
        <member name="M:Accord.Math.Geometry.Circle.DistanceToPoint(AForge.Point)">
            <summary>
              Computes the distance from circle to point.
            </summary>
            
            <param name="point">The point to have its distance from the circle computed.</param>
            
            <returns>The distance from <paramref name="point"/> to this circle.</returns>
            
        </member>
        <member name="P:Accord.Math.Geometry.Circle.Area">
            <summary>
              Gets the area of the circle (πR²).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.Circle.Circumference">
            <summary>
              Gets the circumference of the circle (2πR).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.Circle.Diameter">
            <summary>
              Gets the diameter of the circle (2R).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.Circle.Radius">
            <summary>
              Gets or sets the radius for this circle.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Geometry.Circle.Origin">
            <summary>
              Gets or sets the origin (center) of this circle.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.BrentSearch">
            <summary>
              Brent's root finding and minimization algorithms.
            </summary>
            
            <remarks>
            <para>
              In numerical analysis, Brent's method is a complicated but popular root-finding 
              algorithm combining the bisection method, the secant method and inverse quadratic
              interpolation. It has the reliability of bisection but it can be as quick as some
              of the less reliable methods. The idea is to use the secant method or inverse quadratic 
              interpolation if possible, because they converge faster, but to fall back to the more
              robust bisection method if necessary. Brent's method is due to Richard Brent (1973)
              and builds on an earlier algorithm of Theodorus Dekker (1969).</para>
              
            <para>
              The algorithms implemented in this class are based on the original C source code
              available in Netlib (http://www.netlib.org/c/brent.shar) by Oleg Keselyov, 1991.</para>
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  R.P. Brent (1973). Algorithms for Minimization without Derivatives, Chapter 4. 
                  Prentice-Hall, Englewood Cliffs, NJ. ISBN 0-13-022335-2. </description></item>
                <item><description><a href="http://en.wikipedia.org/wiki/Brent's_method">
                  Wikipedia contributors. "Brent's method." Wikipedia, The Free Encyclopedia.
                  Wikipedia, The Free Encyclopedia, 11 May. 2012. Web. 22 Jun. 2012. </a></description></item>
              </list>
            </para>   
            
            </remarks>
            
            <example>
            <para>
              The following example shows how to compute the maximum,
              minimum and a single root of a univariate function.</para>
              
            <code>
            // Suppose we were given the function x³ + 2x² - 10x and 
            // we have to find its root, maximum and minimum inside 
            // the interval [-4,3]. First, we express this function
            // as a lambda expression:
            Func&gt;double, double> function = x => x * x * x + 2 * x * x - 10 * x;
            
            // And now we can create the search algorithm:
            BrentSearch search = new BrentSearch(function, -4, 3);
            
            // Finally, we can query the information we need
            double max = search.Maximize();  // occurs at -2.61
            double min = search.Minimize();  // occurs at  1.27
            double root = search.FindRoot(); // occurs at  0.50
            </code>
            </example>
            
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
              Constructs a new Brent search algorithm.
            </summary>
            
            <param name="function">The function to be searched.</param>
            <param name="a">Start of search region.</param>
            <param name="b">End of search region.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.FindRoot">
            <summary>
              Attempts to find a root in the interval [a;b] 
            </summary>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Find(System.Double)">
            <summary>
              Attempts to find a value in the interval [a;b] 
            </summary>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Minimize">
            <summary>
              Finds the minimum of the function in the interval [a;b]
            </summary>
            
            <returns>The location of the minimum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Maximize">
            <summary>
              Finds the maximum of the function in the interval [a;b]
            </summary>
            
            <returns>The location of the maximum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Minimize(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Finds the minimum of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to be minimized.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            
            <returns>The location of the minimum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Maximize(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Finds the maximum of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to be maximized.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            
            <returns>The location of the maximum of the function in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.FindRoot(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
              Finds the root of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to have its root computed.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.BrentSearch.Find(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Finds a value of a function in the interval [a;b]
            </summary>
            
            <param name="function">The function to have its root computed.</param>
            <param name="lowerBound">Start of search region.</param>
            <param name="upperBound">End of search region.</param>
            <param name="tol">The tolerance for determining the solution.</param>
            <param name="value">The value to be looked for in the function.</param>
            
            <returns>The location of the zero value in the given interval.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Tolerance">
            <summary>
              Gets or sets the tolerance margin when
              looking for an answer. Default is 1e-6.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.LowerBound">
            <summary>
              Gets or sets the lower bound for the search interval <c>a</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.UpperBound">
            <summary>
              Gets or sets the lower bound for the search interval <c>a</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Solution">
            <summary>
              Gets the solution found in the last call
              to <see cref="M:Accord.Math.Optimization.BrentSearch.Minimize"/>, <see cref="M:Accord.Math.Optimization.BrentSearch.Maximize"/>
              or <see cref="M:Accord.Math.Optimization.BrentSearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Value">
            <summary>
              Gets the value at the solution found in the last call
              to <see cref="M:Accord.Math.Optimization.BrentSearch.Minimize"/>, <see cref="M:Accord.Math.Optimization.BrentSearch.Maximize"/>
              or <see cref="M:Accord.Math.Optimization.BrentSearch.FindRoot"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.BrentSearch.Function">
            <summary>
              Gets the function to be searched.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver">
             <summary>
               Goldfarb-Idnani Quadratic Programming Solver.
             </summary>
             
             <remarks>
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://www.javaquant.net/papers/GoldfarbIdnani.pdf">
                   Goldfarb D., Idnani A. (1982) Dual and Primal-Dual Methods for Solving Strictly Convex Quadratic Programs.
                   Available on: http://www.javaquant.net/papers/GoldfarbIdnani.pdf .</a></description></item>
                 <item><description><a href="http://www.javaquant.net/papers/GoldfarbIdnani.pdf">
                   Berwin A Turlach. QuadProg, Quadratic Programming Solver (implementation in Fortran).
                   Available on:  http://school.maths.uwa.edu.au/~berwin/software/quadprog.html .</a></description></item>
               </list>
             </para>   
             </remarks>
             
             <example>
             <para>
               There are three ways to state a quadratic programming problem in this framework.</para>
               
             <list type="bullet">
               <item><description>
               The first is to state the problem in its canonical form, explicitly stating the
               matrix Q and vector d specifying the quadratic function and the matrices A and
               vector b specifying the problem constraints.</description></item>
               <item><description>
               The second is to state the problem with lambda expressions using symbolic variables.</description></item>
               <item><description>
               The third is to state the problem using text strings.</description></item>
             </list>
               
             <para>  
               In the following section we will provide examples for those ways. 
             </para>
             
             <para>
               This is an example stating the problem using lambdas:</para>
             <code>
             // Solve the following optimization problem:
             //
             //  min f(x) = 2x² - xy + 4y² - 5x - 6y
             // 
             //  s.t.   x - y  ==   5  (x minus y should be equal to 5)
             //             x  >=  10  (x should be greater than or equal to 10)
             //
            
             // In this example we will be using some symbolic processing. 
             // The following variables could be initialized to any value.
             double x = 0, y = 0;
            
             // Create our objective function using a lambda expression
             var f = new QuadraticObjectiveFunction(() => 2 * (x * x) - (x * y) + 4 * (y * y) - 5 * x - 6 * y);
            
             // Now, create the constraints
             List&lt;LinearConstraint> constraints = new List&lt;LinearConstraint>();
             constraints.Add(new LinearConstraint(f, () => x - y == 5));
             constraints.Add(new LinearConstraint(f, () => x >= 10));
            
             // Now we create the quadratic programming solver for 2 variables, using the constraints.
             GoldfarbIdnaniQuadraticSolver solver = new GoldfarbIdnaniQuadraticSolver(2, constraints);
            
             // And attempt to solve it.
             double minimumValue = solver.Minimize(f);
             </code>
             
             <para>
               This is an example stating the problem using strings:</para>
             <code>
             // Solve the following optimization problem:
             //
             //  max f(x) = -2x² + xy - y² + 5y
             // 
             //  s.t.   x - y  ==   5  (x minus y should be equal to 5)
             //             x  >=  10  (x should be greater than or equal to 10)
             //
             //
            
             // Create our objective function using a text string
             var f = new QuadraticObjectiveFunction("-2x² + xy - y² + 5y");
            
             // Now, create the constraints
             List&lt;LinearConstraint> constraints = new List&lt;LinearConstraint>();
             constraints.Add(new LinearConstraint(f, "x - y ==  5"));
             constraints.Add(new LinearConstraint(f, "    x >= 10"));
            
             // Now we create the quadratic programming solver for 2 variables, using the constraints.
             GoldfarbIdnaniQuadraticSolver solver = new GoldfarbIdnaniQuadraticSolver(2, constraints);
            
             // And attempt to solve it.
             double maxValue = solver.Maximize(f);
             </code>
               
             <para>
               And finally, an example stating the problem using matrices:</para>
             <code>
             // Solve the following optimization problem:
             //
             //  min f(x) = 2x² - xy + 4y² - 5x - 6y
             // 
             //  s.t.   x - y  ==   5  (x minus y should be equal to 5)
             //             x  >=  10  (x should be greater than or equal to 10)
             //
             
             // Lets first group the quadratic and linear terms. The
             // quadratic terms are +2x², +3y² and -4xy. The linear 
             // terms are -2x and +1y. So our matrix of quadratic
             // terms can be expressed as:
            
             double[,] Q = // 2x² -1xy +4y²
             {   
                 /*           x              y      */
                 /*x*/ { +2 /*xx*/ *2,  -1 /*xy*/    }, 
                 /*y*/ { -1 /*xy*/   ,  +4 /*yy*/ *2 },
             };
            
             // Accordingly, our vector of linear terms is given by:
            
             double[] d = { -5 /*x*/, -6 /*y*/ }; // -5x -6y
            
             // We have now to express our constraints. We can do it
             // either by directly specifying a matrix A in which each
             // line refers to one of the constraints, expressing the
             // relationship between the different variables in the
             // constraint, like this:
            
             double[,] A = 
             {
                 { 1, -1 }, // This line says that x + (-y) ... (a)
                 { 1,  0 }, // This line says that x alone  ... (b)
             };
            
             double[] b = 
             {
                  5, // (a) ... should be equal to 5.
                 10, // (b) ... should be greater than or equal to 10.
             };
            
             // Equalities must always come first, and in this case
             // we have to specify how many of the constraints are
             // actually equalities:
            
             int numberOfEqualities = 1;
            
            
             // Alternatively, we may use a more explicitly form:
             List&lt;LinearConstraint> list = new List&lt;LinearConstraint>();
            
             // Define the first constraint, which involves only x
             list.Add(new LinearConstraint(numberOfVariables: 1)
                 {
                     // x is the first variable, thus located at
                     // index 0. We are specifying that x >= 10:
            
                     VariablesAtIndices = new[] { 0 }, // index 0 (x)
                     ShouldBe = ConstraintType.GreaterThanOrEqualTo,
                     Value = 10
                 });
            
             // Define the second constraint, which involves x and y
             list.Add(new LinearConstraint(numberOfVariables: 2)
                 {
                     // x is the first variable, located at index 0, and y is
                     // the second, thus located at 1. We are specifying that
                     // x - y = 5 by saying that the variable at position 0 
                     // times 1 plus the variable at position 1 times -1 
                     // should be equal to 5.
            
                     VariablesAtIndices = new int[] { 0, 1 }, // index 0 (x) and index 1 (y)
                     CombinedAs = new double[] { 1, -1 }, // when combined as x - y
                     ShouldBe = ConstraintType.EqualTo,
                     Value = 5
                 });
            
            
             // Now we can finally create our optimization problem
             var target = new GoldfarbIdnaniQuadraticSolver(numberOfVariables: 2, constraints: list);
            
             // And attempt to solve it.
             double minimumValue = target.Minimize(Q, d);
             </code>
             </example>
             
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.#ctor(System.Int32,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.LinearConstraint})">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of variables.</param>
            <param name="constraints">The problem's constraints.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.#ctor(System.Int32,Accord.Math.Optimization.LinearConstraintCollection)">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of variables.</param>
            <param name="constraints">The problem's constraints.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.#ctor(System.Int32,System.Double[0:,0:],System.Double[],System.Int32)">
            <summary>
              Constructs a new instance of the <see cref="T:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver"/> class.
            </summary>
            
            <param name="numberOfVariables">The number of variables.</param>
            <param name="constraintMatrix">The constraints matrix <c>A</c>.</param>
            <param name="constraintValues">The constraints values <c>b</c>.</param>
            <param name="numberOfEqualities">The number of equalities in the constraints.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Maximize(Accord.Math.Optimization.QuadraticObjectiveFunction)">
            <summary>
              Maximizes the function.
            </summary>
            
            <param name="function">The function to be maximized.</param>
            <returns>The maximum value at the solution found.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Minimize(Accord.Math.Optimization.QuadraticObjectiveFunction)">
            <summary>
              Minimizes the function.
            </summary>
            
            <param name="function">The function to be minimized.</param>
            <returns>The minimum value at the solution found.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Minimize(System.Double[0:,0:],System.Double[])">
            <summary>
              Minimizes the function.
            </summary>
            
            <param name="hessian">The Hessian matrix <c>D</c> for the quadratic terms.</param>
            <param name="linearTerms">The vector of linear terms <c>d</c>.</param>
            <returns>The minimum value at the solution found.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Maximize(System.Double[0:,0:],System.Double[])">
            <summary>
              Maximizes the function.
            </summary>
            
            <param name="hessian">The Hessian matrix <c>D</c> for the quadratic terms.</param>
            <param name="linearTerms">The vector of linear terms <c>d</c>.</param>
            <returns>The maximum value at the solution found.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.NumberOfVariables">
            <summary>
              Gets the number of variables in the quadratic problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.NumberOfConstraints">
            <summary>
              Gets the total number of constraints in the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.NumberOfEqualities">
            <summary>
              Gets how many constraints are inequality constraints.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Iterations">
            <summary>
              Gets the total number of iterations performed on the
              last call to the <see cref="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Minimize(Accord.Math.Optimization.QuadraticObjectiveFunction)"/> method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Deletions">
            <summary>
              Gets the total number of constraint removals performed
              on the last call to the <see cref="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Minimize(Accord.Math.Optimization.QuadraticObjectiveFunction)"/> method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Lagrangian">
            <summary>
              Gets the Lagrangian multipliers for the
              last solution found.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Solution">
            <summary>
              Gets the last solution found on the last call
              to the <see cref="M:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Minimize(Accord.Math.Optimization.QuadraticObjectiveFunction)"/> method.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Value">
            <summary>
              Gets the value found at the <see cref="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.ActiveConstraints">
            <summary>
              Gets the indices of the active constraints
              found at the last <see cref="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.Solution"/>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.ConstraintMatrix">
            <summary>
              Gets the constraint matrix <c>A</c> for the problem.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.GoldfarbIdnaniQuadraticSolver.ConstraintValues">
            <summary>
              Gets the constraint values <c>b</c> for the problem.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Optimization.QuadraticObjectiveFunction">
            <summary>
              Quadratic objective function.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.#ctor(System.Double[0:,0:],System.Double[],System.String[])">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="hessian">A Hessian matrix of quadratic terms defining the quadratic objective function.</param>
            <param name="linearTerms">The vector of linear terms associated with <paramref name="hessian"/>.</param>
            <param name="variables">The name for each variable in the problem.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.#ctor(System.String)">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="function">A <see cref="T:System.String"/> containing
            the function in the form similar to "ax²+b".</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.#ctor(System.Linq.Expressions.Expression{System.Func{System.Double}})">
            <summary>
              Creates a new objective function specified through a string.
            </summary>
            
            <param name="function">A <see cref="T:System.Linq.Expressions.Expression`1"/> containing 
            the function in the form of a lambda expression.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.GetQuadraticTermsMatrix">
            <summary>
              Gets the Hessian matrix of quadratic terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.GetLinearTermsVector">
            <summary>
              Gets the vector of linear terms.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.ToString">
            <summary>
              Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            
            <returns>
              A <see cref="T:System.String"/> that represents this instance.
            </returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.QuadraticObjectiveFunction.TryParse(System.String,Accord.Math.Optimization.QuadraticObjectiveFunction@)">
            <summary>
              Attempts to create a <see cref="T:Accord.Math.Optimization.QuadraticObjectiveFunction"/>
              from a <see cref="T:System.String"/> representation.
            </summary>
            
            <param name="str">The string containing the function in textual form.</param>
            <param name="function">The resulting function, if it could be parsed.</param>
            
            <returns><c>true</c> if the function could be parsed
              from the string, <c>false</c> otherwise.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.Variables">
            <summary>
              Gets input variable's labels for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.Indices">
            <summary>
              Gets the index of each input variable in the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.NumberOfVariables">
            <summary>
              Gets the number of input variables for the function.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.QuadraticObjectiveFunction.Function">
            <summary>
              Gets the objective function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.LuDecompositionD">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.LuDecompositionD.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.#ctor(System.Decimal[0:,0:])">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.#ctor(System.Decimal[0:,0:],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Solve(System.Decimal[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.SolveTranspose(System.Decimal[0:,0:])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Solve(System.Decimal[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.LuDecompositionD.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
              Please see remarks for important information regarding
              numerical stability when using this method.
            </summary>
            
            <remarks>
              Please keep in mind this is not one of the most reliable methods
              for checking singularity of a matrix. For a more reliable method,
              please use <see cref="M:Accord.Math.Matrix.IsSingular(System.Double[0:,0:])"/> or the 
              <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition"/>.
            </remarks>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.LuDecompositionD.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergNode">
             <summary>
               Denavit Hartenberg Model Combinator class to make combination
               of models to create a complex model composed of multiple chains.
             </summary>
            
             <example>
             <para>
               The following example shows the creation and animation of a
               2-link planar manipulator with a dual 2-link planar gripper.
               </para>
             
             <code>
               // Create the DH-model at (0, 0, 0) location
            	  DenavitHartenbergModel model = new DenavitHartenbergModel();
            	  
            	  // Add the first joint
            	  model.Joints.Add(alpha: 0, theta: Math.PI / 4, radius: 35, offset: 0);
            	  
            	  // Add the second joint
            	  model.Joints.Add(alpha: 0, theta: -Math.PI / 3, radius: 35, offset: 0);
            	
            	  // Create the top finger
            	  DenavitHartenbergModel model_tgripper = new DenavitHartenbergModel();
            	  model_tgripper.Joints.Add(alpha: 0, theta:  Math.PI / 4, radius: 20, offset: 0);
            	  model_tgripper.Joints.Add(alpha: 0, theta: -Math.PI / 3, radius: 20, offset: 0);
            	  
            	  // Create the bottom finger
            	  DenavitHartenbergModel model_bgripper = new DenavitHartenbergModel();
            	  model_bgripper.Joints.Add(0, -Math.PI / 4, 20, 0);
            	  model_bgripper.Joints.Add(0,  Math.PI / 3, 20, 0);
            	  
            	  // Create the model combinator from the parent model
            	  DenavitHartenbergModelCombinator arm = new DenavitHartenbergModelCombinator(model);
            	  
            	  // Add the top finger
            	  arm.Children.Add(model_tgripper);
            	  
            	  // Add the bottom finger
            	  arm.Children.Add(model_bgripper);
            	  
            	  // Calculate the whole model (parent model + children models)
            	  arm.Compute();
            	</code>
             </example>
             
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergNode.#ctor(Accord.Math.Kinematics.DenavitHartenbergModel)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNode"/> class.
            </summary>
            
            <param name="model">The inner model contained at this node.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergNode.Compute">
            <summary>
              Calculates the whole combined model (this model plus all its 
              children plus all the children of the children and so on)
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergNode.Parent">
            <summary>
              Gets the parent of this node.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergNode.Model">
            <summary>
              Gets the model contained at this node.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergNode.Children">
            <summary>
              Gets the collection of models attached to this node.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Kinematics.DenavitHartenbergNodeCollection">
            <summary>
              Collection of Denavit-Hartenberg model nodes.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergNodeCollection.#ctor(Accord.Math.Kinematics.DenavitHartenbergNode)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNodeCollection"/> class.
            </summary>
            
            <param name="owner">The <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNode"/> owner.</param>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergNodeCollection.Add(Accord.Math.Kinematics.DenavitHartenbergModel)">
            <summary>
              Adds a children model to the end of this <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNodeCollection"/>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Kinematics.DenavitHartenbergNodeCollection.InsertItem(System.Int32,Accord.Math.Kinematics.DenavitHartenbergNode)">
            <summary>
               Inserts an element into the Collection&lt;T> at the specified index.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Kinematics.DenavitHartenbergNodeCollection.Owner">
            <summary>
              Gets the owner of this collection (i.e. the parent
              <see cref="T:Accord.Math.Kinematics.DenavitHartenbergNode"/> which owns the
              children contained at this collection.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.SingularValueDecomposition">
             <summary>
               Singular Value Decomposition for a rectangular matrix.
             </summary>
            
             <remarks>
              <para>
                  For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the singular value decomposition
               is an m-by-n orthogonal matrix <c>U</c>, an n-by-n diagonal matrix <c>S</c>, and
               an n-by-n orthogonal matrix <c>V</c> so that <c>A = U * S * V'</c>.
               The singular values, <c>sigma[k] = S[k,k]</c>, are ordered so that
               <c>sigma[0] &gt;= sigma[1] &gt;= ... &gt;= sigma[n-1]</c>.</para>
              <para>
               The singular value decomposition always exists, so the constructor will
               never fail. The matrix condition number and the effective numerical
               rank can be computed from this decomposition.</para>
              <para>
               WARNING! Please be aware that if A has less rows than columns, it is better
               to compute the decomposition on the transpose of A and then swap the left
               and right eigenvectors. If the routine is computed on A directly, the diagonal
               of singular values may contain one or more zeros. The identity A = U * S * V'
               may still hold, however. To overcome this problem, pass true to the
               <see cref="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean,System.Boolean)">autoTranspose</see> argument of the class constructor.</para>
              <para>
               This routine computes the economy decomposition of A.</para> 
             </remarks>
             
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:])">
             <summary>
               Constructs a new singular value decomposition.
             </summary>
            
             <param name="value">
               The matrix to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean)">
            <summary>
                Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.#ctor(System.Double[0:,0:],System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
              Constructs a new singular value decomposition.
            </summary>
            
            <param name="value">
              The matrix to be decomposed.</param>
            <param name="computeLeftSingularVectors">
              Pass <see langword="true"/> if the left singular vector matrix U 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="computeRightSingularVectors">
              Pass <see langword="true"/> if the right singular vector matrix V 
              should be computed. Pass <see langword="false"/> otherwise. Default
              is <see langword="true"/>.</param>
            <param name="autoTranspose">
              Pass <see langword="true"/> to automatically transpose the value matrix in
              case JAMA's assumptions about the dimensionality of the matrix are violated.
              Pass <see langword="false"/> otherwise. Default is <see langword="false"/>.</param>
            <param name="inPlace">
              Pass <see langword="true"/> to perform the decomposition in place. The matrix
              <paramref name="value"/> will be destroyed in the process, resulting in less
              memory comsumption.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Solve(System.Double[0:,0:])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.SolveForDiagonal(System.Double[])">
            <summary>
              Solves a linear equation system of the form AX = B.
            </summary>
            <param name="value">Parameter B from the equation AX = B.</param>
            <returns>The solution X from equation AX = B.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Solve(System.Double[])">
            <summary>
              Solves a linear equation system of the form Ax = b.
            </summary>
            <param name="value">The b from the equation Ax = b.</param>
            <returns>The x from equation Ax = b.</returns>
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Inverse">
             <summary>
               Computes the (pseudo-)inverse of the matrix given to the Singular value decomposition.
             </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.SingularValueDecomposition.Clone">
             <summary>
               Creates a new object that is a copy of the current instance.
             </summary>
             <returns>
               A new object that is a copy of this instance.
             </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Condition">
             <summary>
               Returns the condition number <c>max(S) / min(S)</c>.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Threshold">
             <summary>
               Returns the singularity threshold.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.TwoNorm">
             <summary>
               Returns the Two norm.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Rank">
             <summary>
               Returns the effective numerical matrix rank.
             </summary>
            
             <value>Number of non-negligible singular values.</value>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.IsSingular">
             <summary>
               Gets whether the decomposed matrix is singular.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Diagonal">
             <summary>
               Gets the one-dimensional array of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.DiagonalMatrix">
             <summary>
              Returns the block diagonal matrix of singular values.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.RightSingularVectors">
             <summary>
               Returns the V matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.LeftSingularVectors">
             <summary>
               Returns the U matrix of Singular Vectors.
             </summary>        
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.Ordering">
             <summary>
               Returns the ordering in which the singular values have been sorted.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.AbsoluteDeterminant">
             <summary>
               Returns the absolute value of the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.LogDeterminant">
             <summary>
               Returns the log of the absolute value for the matrix determinant.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.PseudoDeterminant">
             <summary>
               Returns the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.SingularValueDecomposition.LogPseudoDeterminant">
             <summary>
               Returns the log of the pseudo-determinant for the matrix.
             </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.GramSchmidtOrthogonalization">
            <summary>
              Gram-Schmidt Orthogonalization.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.GramSchmidtOrthogonalization.#ctor(System.Double[0:,0:])">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Decompositions.GramSchmidtOrthogonalization"/> class.
            </summary>
            
            <param name="value">The matrix <c>A</c> to be decomposed.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.GramSchmidtOrthogonalization.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:Accord.Math.Decompositions.GramSchmidtOrthogonalization"/> class.
            </summary>
            
            <param name="value">The matrix <c>A</c> to be decomposed.</param>
            <param name="modified">True to use modified Gram-Schmidt; false
              otherwise. Default is true (and is the recommended setup).</param>
            
        </member>
        <member name="P:Accord.Math.Decompositions.GramSchmidtOrthogonalization.OrthogonalFactor">
            <summary>
              Returns the orthogonal factor matrix <c>Q</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.GramSchmidtOrthogonalization.UpperTriangularFactor">
            <summary>
              Returns the upper triangular factor matrix <c>R</c>.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Comparers.CustomComparer`1">
            <summary>
              Custom comparer which accepts any delegate or
              anonymous function to perform value comparisons.
            </summary>
            
            <typeparam name="T">The type of objects to compare.</typeparam>
            
            <example>
            <code>
              // Assume we have values to sort
              double[] values = { 0, 5, 3, 1, 8 };
              
              // We can create an ad-hoc sorting rule using
              Array.Sort(values, new CustomComparer&lt;double>((a, b) => -a.CompareTo(b)));
              
              // Result will be { 8, 5, 3, 1, 0 }.
            </code>
            </example>
            
        </member>
        <member name="M:Accord.Math.Comparers.CustomComparer`1.#ctor(System.Func{`0,`0,System.Int32})">
            <summary>
              Constructs a new <see cref="T:Accord.Math.Comparers.CustomComparer`1"/>.
            </summary>
            
            <param name="comparer">The comparer function.</param>
            
        </member>
        <member name="M:Accord.Math.Comparers.CustomComparer`1.Compare(`0,`0)">
            <summary>
              Compares two objects and returns a value indicating
              whether one is less than, equal to, or greater than
              the other.
            </summary>
            
            <param name="x">The first object to compare.</param>
            <param name="y">The second object to compare.</param>
            
            <returns>A signed integer that indicates the relative values of x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Comparers.CustomComparer`1.Equals(`0,`0)">
            <summary>
              Determines whether the specified objects are equal.
            </summary>
            
            <param name="x">The first object of type T to compare.</param>
            <param name="y">The second object of type T to compare.</param>
            
            <returns>true if the specified objects are equal; otherwise, false.</returns>
            
        </member>
        <member name="M:Accord.Math.Comparers.CustomComparer`1.GetHashCode(`0)">
            <summary>
              Returns a hash code for the given object.
            </summary>
            
            <param name="obj">The object.</param>
            
            <returns>
              A hash code for the given object, suitable for use in
              hashing algorithms and data structures like a hash table. 
            </returns>
            
        </member>
        <member name="T:Accord.Math.Optimization.AugmentedLagrangianSolver">
             <summary>
               Augmented Lagrangian method for constrained non-linear optimization.
             </summary>
             
             <remarks>
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://ab-initio.mit.edu/nlopt">
                   Steven G. Johnson, The NLopt nonlinear-optimization package, http://ab-initio.mit.edu/nlopt </a></description></item>
                 <item><description><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.72.6121">
                   E. G. Birgin and J. M. Martinez, "Improving ultimate convergence of an augmented Lagrangian
                   method," Optimization Methods and Software vol. 23, no. 2, p. 177-195 (2008). </a></description></item>
               </list>
             </para>   
             </remarks>
             
             <example>
             <para>
               In this framework, it is possible to state a non-linear programming problem
               using either symbolic processing or vector-valued functions. The following 
               example demonstrates the former.</para>
               
             <code>
             // Suppose we would like to minimize the following function:
             //
             //    f(x,y) = min 100(y-x²)²+(1-x)²
             //
             // Subject to the constraints
             //
             //    x >= 0  (x must be positive)
             //    y >= 0  (y must be positive)
             //
            
             // In this example we will be using some symbolic processing. 
             // The following variables could be initialized to any value.
            
             double x = 0, y = 0;
            
            
             // First, we create our objective function
             var f = new NonlinearObjectiveFunction(
            
                 // This is the objective function:  f(x,y) = min 100(y-x²)²+(1-x)²
                 function: () => 100 * Math.Pow(y - x * x, 2) + Math.Pow(1 - x, 2),
            
                 // The gradient vector:
                 gradient: () => new[] 
                 {
                     2 * (200 * Math.Pow(x, 3) - 200 * x * y + x - 1), // df/dx = 2(200x³-200xy+x-1)
                     200 * (y - x*x)                                   // df/dy = 200(y-x²)
                 }
            
             );
            
            
             // Now we can start stating the constraints
             var constraints = new List&lt;NonlinearConstraint>();
            
             // Add the non-negativity constraint for x
             constraints.Add(new NonlinearConstraint(f,
            
                 // 1st constraint: x should be greater than or equal to 0
                 function: () => x, shouldBe: ConstraintType.GreaterThanOrEqualTo, value: 0,
            
                 gradient: () => new[] { 1.0, 0.0 }
             ));
            
             // Add the non-negativity constraint for y
             constraints.Add(new NonlinearConstraint(f,
            
                 // 2nd constraint: y should be greater than or equal to 0
                 function: () => y, shouldBe: ConstraintType.GreaterThanOrEqualTo, value: 0,
            
                 gradient: () => new[] { 0.0, 1.0 }
             ));
            
            
             // Finally, we create the non-linear programming solver
             var solver = new AugmentedLagrangianSolver(2, constraints);
            
             // And attempt to solve the problem
             double minValue = solver.Minimize(f);
             </code>
             </example>
             
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.#ctor(System.Int32,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.NonlinearConstraint})">
            <summary>
              Creates a new instance of the Augmented Lagrangian algorithm.
            </summary>
            
            <param name="numberOfVariables">The number of free parameters in the optimization problem.</param>
            <param name="constraints">The <see cref="T:Accord.Math.Optimization.NonlinearConstraint"/>s to which the solution must be subjected.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.#ctor(Accord.Math.Optimization.IGradientOptimizationMethod,System.Collections.Generic.IEnumerable{Accord.Math.Optimization.NonlinearConstraint})">
            <summary>
              Creates a new instance of the Augmented Lagrangian algorithm.
            </summary>
            
            <param name="innerSolver">The <see cref="T:Accord.Math.Optimization.IGradientOptimizationMethod">unconstrained optimization
              method</see> used internally to solve the dual of this optimization problem.</param>
            <param name="constraints">The <see cref="T:Accord.Math.Optimization.NonlinearConstraint"/>s to which the solution must be subjected.</param>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Minimize(Accord.Math.Optimization.NonlinearObjectiveFunction)">
            <summary>
              Minimizes the given function. 
            </summary>
            
            <param name="function">The function to be minimized.</param>
            
            <returns>The minimum value found at the <see cref="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Solution"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Minimize(System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              Minimizes the defined function. 
            </summary>
            
            <param name="function">The function to be minimized.</param>
            <param name="gradient">The gradient of the given <paramref name="function"/>.</param>
            
            <returns>The minimum value found at the <see cref="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Solution"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Maximize(Accord.Math.Optimization.NonlinearObjectiveFunction)">
            <summary>
              Maximizes the given function. 
            </summary>
            
            <param name="function">The function to be maximized.</param>
            
            <returns>The maximum value found at the <see cref="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Solution"/>.</returns>
            
        </member>
        <member name="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Maximize(System.Func{System.Double[],System.Double},System.Func{System.Double[],System.Double[]})">
            <summary>
              maximizes the defined function. 
            </summary>
            
            <param name="function">The function to be maximized.</param>
            <param name="gradient">The gradient of the given <paramref name="function"/>.</param>
            
            <returns>The maximum value found at the <see cref="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Solution"/>.</returns>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Parameters">
            <summary>
              Gets the number of variables (free parameters)
              in the optimization problem.
            </summary>
            
            <value>The number of parameters.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Iterations">
            <summary>
              Gets the number of iterations performed in the last
              call to <see cref="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Minimize(Accord.Math.Optimization.NonlinearObjectiveFunction)"/>.
            </summary>
            
            <value>
              The number of iterations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Evaluations">
            <summary>
              Gets the number of function evaluations performed
              in the last call to <see cref="M:Accord.Math.Optimization.AugmentedLagrangianSolver.Minimize(Accord.Math.Optimization.NonlinearObjectiveFunction)"/>.
            </summary>
            
            <value>
              The number of evaluations performed
              in the previous optimization.</value>
              
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.MaxEvaluations">
            <summary>
              Gets or sets the maximum number of evaluations
              to be performed during optimization. Default
              is 0 (evaluate until convergence).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Function">
            <summary>
              Gets or sets the function to be optimized.
            </summary>
            
            <value>The function to be optimized.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Gradient">
            <summary>
              Gets or sets a function returning the gradient
              vector of the function to be optimized for a
              given value of its free parameters.
            </summary>
            
            <value>The gradient function.</value>
            
        </member>
        <member name="P:Accord.Math.Optimization.AugmentedLagrangianSolver.Solution">
            <summary>
              Gets the solution found, the values of the
              parameters which optimizes the function.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Distance">
            <summary>
              Static class Distance. Defines a set of extension methods defining distance measures.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.SquareMahalanobis(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
              Gets the Square Mahalanobis distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="precision">
              The inverse of the covariance matrix of the distribution for the two points x and y.
            </param>
            
            <returns>The Square Mahalanobis distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.SquareMahalanobis(System.Double[],System.Double[],Accord.Math.Decompositions.SingularValueDecomposition)">
            <summary>
              Gets the Square Mahalanobis distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="covariance">
              The <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition"/> of the covariance 
              matrix of the distribution for the two points x and y.
            </param>
            
            <returns>The Square Mahalanobis distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Mahalanobis(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
              Gets the Mahalanobis distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="precision">
              The inverse of the covariance matrix of the distribution for the two points x and y.
            </param>
            
            <returns>The Mahalanobis distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Mahalanobis(System.Double[],System.Double[],Accord.Math.Decompositions.SingularValueDecomposition)">
            <summary>
              Gets the Mahalanobis distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            <param name="covariance">
              The <see cref="T:Accord.Math.Decompositions.SingularValueDecomposition"/> of the covariance 
              matrix of the distribution for the two points x and y.
            </param>
            
            <returns>The Mahalanobis distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Manhattan(System.Double[],System.Double[])">
            <summary>
              Gets the Manhattan distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Manhattan distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Manhattan(System.Int32[],System.Int32[])">
            <summary>
              Gets the Manhattan distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Manhattan distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Chebyshev(System.Double[],System.Double[])">
            <summary>
              Gets the Chebyshev distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Chebyshev distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.SquareEuclidean(System.Double[],System.Double[])">
            <summary>
              Gets the Square Euclidean distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Square Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.SquareEuclidean(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Gets the Square Euclidean distance between two points.
            </summary>
            
            <param name="x1">The first coordinate of first point in space.</param>
            <param name="y1">The second coordinate of first point in space.</param>
            <param name="x2">The first coordinate of second point in space.</param>
            <param name="y2">The second coordinate of second point in space.</param>
            
            <returns>The Square Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Euclidean(System.Double[],System.Double[])">
            <summary>
              Gets the Euclidean distance between two points.
            </summary>
            
            <param name="x">A point in space.</param>
            <param name="y">A point in space.</param>
            
            <returns>The Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Euclidean(System.Double,System.Double,System.Double,System.Double)">
            <summary>
              Gets the Euclidean distance between two points.
            </summary>
            
            <param name="x1">The first coordinate of first point in space.</param>
            <param name="y1">The second coordinate of first point in space.</param>
            <param name="x2">The first coordinate of second point in space.</param>
            <param name="y2">The second coordinate of second point in space.</param>
            
            <returns>The Euclidean distance between x and y.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Modular(System.Int32,System.Int32,System.Int32)">
            <summary>
              Gets the Modulo-m distance between two integers <c>a</c> and <c>b</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.Modular(System.Double,System.Double,System.Double)">
            <summary>
              Gets the Modulo-m distance between two real values <c>a</c> and <c>b</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[],System.Double[])">
            <summary>
              Bhattacharyya distance between two normalized histograms.
            </summary>
            
            <param name="histogram1">A normalized histogram.</param>
            <param name="histogram2">A normalized histogram.</param>
            <returns>The Bhattacharyya distance between the two histograms.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
              Bhattacharyya distance between two matrices.
            </summary>
            
            <param name="x">The first matrix <c>x</c>.</param>
            <param name="y">The first matrix <c>y</c>.</param>
            
            <returns>The Bhattacharyya distance between the two matrices.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[],System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
              Bhattacharyya distance between two Gaussian distributions.
            </summary>
            
            <param name="meanX">Mean for the first distribution.</param>
            <param name="covX">Covariance matrix for the first distribution.</param>
            <param name="meanY">Mean for the second distribution.</param>
            <param name="covY">Covariance matrix for the second distribution.</param>
            
            <returns>The Bhattacharyya distance between the two distributions.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Bhattacharyya(System.Double[],System.Double[0:,0:],System.Double,System.Double[],System.Double[0:,0:],System.Double)">
            <summary>
              Bhattacharyya distance between two Gaussian distributions.
            </summary>
            
            <param name="meanX">Mean for the first distribution.</param>
            <param name="covX">Covariance matrix for the first distribution.</param>
            <param name="meanY">Mean for the second distribution.</param>
            <param name="covY">Covariance matrix for the second distribution.</param>
            <param name="lnDetCovX">The logarithm of the determinant for 
              the covariance matrix of the first distribution.</param>
            <param name="lnDetCovY">The logarithm of the determinant for 
              the covariance matrix of the second distribution.</param>
            
            <returns>The Bhattacharyya distance between the two distributions.</returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Levenshtein(System.String,System.String)">
            <summary>
              Levenshtein distance between two strings.
            </summary>
            
            <param name="x">The first string <c>x</c>.</param>
            <param name="y">The first string <c>y</c>.</param>
            
            <remarks>
              Based on the standard implementation available on Wikibooks:
              http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance
            </remarks>
            
            <returns></returns>
            
        </member>
        <member name="M:Accord.Math.Distance.Hamming(System.Boolean[],System.Boolean[])">
            <summary>
              Hamming distance between two Boolean vectors.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.Hamming(System.Double[],System.Double[])">
            <summary>
              Hamming distance between two double vectors
              containing only 0 (false) or 1 (true) values.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.BitwiseHamming(System.Byte[],System.Byte[])">
            <summary>
              Bitwise hamming distance between two sequences of bytes.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Distance.BitwiseHamming(System.Collections.BitArray,System.Collections.BitArray)">
            <summary>
              Bitwise hamming distance between two bit arrays.
            </summary>
            
        </member>
        <member name="T:Accord.Math.Decompositions.QrDecompositionF">
            <summary>
                 QR decomposition for a rectangular matrix.
            </summary>
            <remarks>
            <para>
              For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
              is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
              matrix <c>R</c> so that <c>A = Q * R</c>.</para>
            <para>
              The QR decomposition always exists, even if the matrix does not have
              full rank, so the constructor will never fail. The primary use of the
              QR decomposition is in the least squares solution of nonsquare systems
              of simultaneous linear equations.
              This will fail if <see cref="P:Accord.Math.Decompositions.QrDecompositionF.FullRank"/> returns <see langword="false"/>.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.#ctor(System.Single[0:,0:])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.#ctor(System.Single[0:,0:],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Solve(System.Single[0:,0:])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.SolveTranspose(System.Single[0:,0:])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Solve(System.Single[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecompositionF.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecompositionF.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.QrDecomposition">
            <summary>
                 QR decomposition for a rectangular matrix.
            </summary>
            <remarks>
            <para>
              For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition
              is an m-by-n orthogonal matrix <c>Q</c> and an n-by-n upper triangular
              matrix <c>R</c> so that <c>A = Q * R</c>.</para>
            <para>
              The QR decomposition always exists, even if the matrix does not have
              full rank, so the constructor will never fail. The primary use of the
              QR decomposition is in the least squares solution of nonsquare systems
              of simultaneous linear equations.
              This will fail if <see cref="P:Accord.Math.Decompositions.QrDecomposition.FullRank"/> returns <see langword="false"/>.</para>  
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.#ctor(System.Double[0:,0:])">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>Constructs a QR decomposition.</summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Solve(System.Double[0:,0:])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.SolveTranspose(System.Double[0:,0:])">
            <summary>Least squares solution of <c>X * A = B</c></summary>
            <param name="value">Right-hand-side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>A matrix that minimized the two norm of <c>X * Q * R - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix column dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Solve(System.Double[])">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Inverse">
            <summary>Least squares solution of <c>A * X = I</c></summary>
        </member>
        <member name="M:Accord.Math.Decompositions.QrDecomposition.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="P:Accord.Math.Decompositions.QrDecomposition.Diagonal">
            <summary>Returns the diagonal of <c>R</c>.</summary>
        </member>
        <member name="T:Accord.Math.Decompositions.JaggedLuDecompositionF">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              <para>
                For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the LU decomposition is an m-by-n
                unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
                and a permutation vector <c>piv</c> of length m so that <c>A(piv) = L*U</c>.
                If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.</para>
              <para>
                The LU decomposition with pivoting always exists, even if the matrix is
                singular, so the constructor will never fail.  The primary use of the
                LU decomposition is in the solution of square systems of simultaneous
                linear equations. This will fail if <see cref="P:Accord.Math.Decompositions.JaggedLuDecompositionF.Nonsingular"/> returns
                <see langword="false"/>.
              </para>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.#ctor(System.Single[][],System.Boolean,System.Boolean)">
            <summary>
              Constructs a new LU decomposition.
            </summary>    
            <param name="value">The matrix A to be decomposed.</param>
            <param name="inPlace">True if the decomposition should be performed over the
            <paramref name="value"/> matrix rather than on a copy of it. If true, the
            matrix will be destroyed during the decomposition. Default is false.</param>
            <param name="transpose">True if the decomposition should be performed on
            the transpose of A rather than A itself, false otherwise. Default is false.</param>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Inverse">
            <summary>
              Solves a set of equation systems of type <c>A * X = I</c>.
            </summary>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Solve(System.Single[][])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.SolveTranspose(System.Single[][])">
            <summary>
              Solves a set of equation systems of type <c>X * A = B</c>.
            </summary>
            <param name="value">Right hand side matrix with as many columns as <c>A</c> and any number of rows.</param>
            <returns>Matrix <c>X</c> so that <c>X * L * U = A</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Solve(System.Single[])">
            <summary>
              Solves a set of equation systems of type <c>A * X = B</c>.
            </summary>
            <param name="value">Right hand side column vector with as many rows as <c>A</c>.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
            
        </member>
        <member name="M:Accord.Math.Decompositions.JaggedLuDecompositionF.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.Nonsingular">
            <summary>
              Returns if the matrix is non-singular (i.e. invertible).
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.Determinant">
            <summary>
              Returns the determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.LogDeterminant">
            <summary>
              Returns the log-determinant of the matrix.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.LowerTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.UpperTriangularFactor">
            <summary>
              Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.
            </summary>
            
        </member>
        <member name="P:Accord.Math.Decompositions.JaggedLuDecompositionF.PivotPermutationVector">
            <summary>
              Returns the pivot permutation vector.
            </summary>
            
        </member>
        <member name="T:Accord.Math.HartleyTransform">
            <summary>
              Hartley Transformation.
            </summary>
            
            <para>
              In mathematics, the Hartley transform is an integral transform closely related
              to the Fourier transform, but which transforms real-valued functions to real-
              valued functions. It was proposed as an alternative to the Fourier transform by
              R. V. L. Hartley in 1942, and is one of many known Fourier-related transforms. 
              Compared to the Fourier transform, the Hartley transform has the advantages of 
              transforming real functions to real functions (as opposed to requiring complex 
              numbers) and of being its own inverse.</para>
            
            <remarks>
              References:
              <list type="bullet">
                <item><description>
                  Wikipedia contributors, "Hartley transform," Wikipedia, The Free Encyclopedia,
                  available at: http://en.wikipedia.org/w/index.php?title=Hartley_transform </description></item>
                <item><description>
                  K. R. Castleman, Digital Image Processing. Chapter 13, p.289.
                  Prentice. Hall, 1998.</description></item>
                <item><description>
                  Poularikas A. D. “The Hartley Transform”. The Handbook of Formulas and 
                  Tables for Signal Processing. Ed. Alexander D. Poularikas, 1999.</description></item>
              </list>
            </remarks>
            
        </member>
        <member name="M:Accord.Math.HartleyTransform.DHT(System.Double[])">
            <summary>
              Forward Hartley Transform.
            </summary>
            
        </member>
        <member name="M:Accord.Math.HartleyTransform.DHT(System.Double[0:,0:])">
            <summary>
              Forward Hartley Transform.
            </summary>
            
        </member>
    </members>
</doc>
